# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023
# This file is distributed under the same license as the pandas package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: pandas 2.1.3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-11-12 17:37+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../source/user_guide/basics.rst:3
msgid "{{ header }}"
msgstr ""

#: ../../source/user_guide/basics.rst:7
msgid "Essential basic functionality"
msgstr ""

#: ../../source/user_guide/basics.rst:9
msgid "Here we discuss a lot of the essential functionality common to the pandas data structures. To begin, let's create some example objects like we did in the :ref:`10 minutes to pandas <10min>` section:"
msgstr ""

#: ../../source/user_guide/basics.rst:22
msgid "Head and tail"
msgstr ""

#: ../../source/user_guide/basics.rst:24
msgid "To view a small sample of a Series or DataFrame object, use the :meth:`~DataFrame.head` and :meth:`~DataFrame.tail` methods. The default number of elements to display is five, but you may pass a custom number."
msgstr ""

#: ../../source/user_guide/basics.rst:37
msgid "Attributes and underlying data"
msgstr ""

#: ../../source/user_guide/basics.rst:39
msgid "pandas objects have a number of attributes enabling you to access the metadata"
msgstr ""

#: ../../source/user_guide/basics.rst:41
msgid "**shape**: gives the axis dimensions of the object, consistent with ndarray"
msgstr ""

#: ../../source/user_guide/basics.rst:44
msgid "Axis labels"
msgstr ""

#: ../../source/user_guide/basics.rst:43
msgid "**Series**: *index* (only axis)"
msgstr ""

#: ../../source/user_guide/basics.rst:44
msgid "**DataFrame**: *index* (rows) and *columns*"
msgstr ""

#: ../../source/user_guide/basics.rst:46
msgid "Note, **these attributes can be safely assigned to**!"
msgstr ""

#: ../../source/user_guide/basics.rst:54
msgid "pandas objects (:class:`Index`, :class:`Series`, :class:`DataFrame`) can be thought of as containers for arrays, which hold the actual data and do the actual computation. For many types, the underlying array is a :class:`numpy.ndarray`. However, pandas and 3rd party libraries may *extend* NumPy's type system to add support for custom arrays (see :ref:`basics.dtypes`)."
msgstr ""

#: ../../source/user_guide/basics.rst:61
msgid "To get the actual data inside a :class:`Index` or :class:`Series`, use the ``.array`` property"
msgstr ""

#: ../../source/user_guide/basics.rst:69
msgid ":attr:`~Series.array` will always be an :class:`~pandas.api.extensions.ExtensionArray`. The exact details of what an :class:`~pandas.api.extensions.ExtensionArray` is and why pandas uses them are a bit beyond the scope of this introduction. See :ref:`basics.dtypes` for more."
msgstr ""

#: ../../source/user_guide/basics.rst:73
msgid "If you know you need a NumPy array, use :meth:`~Series.to_numpy` or :meth:`numpy.asarray`."
msgstr ""

#: ../../source/user_guide/basics.rst:81
msgid "When the Series or Index is backed by an :class:`~pandas.api.extensions.ExtensionArray`, :meth:`~Series.to_numpy` may involve copying data and coercing values. See :ref:`basics.dtypes` for more."
msgstr ""

#: ../../source/user_guide/basics.rst:85
msgid ":meth:`~Series.to_numpy` gives some control over the ``dtype`` of the resulting :class:`numpy.ndarray`. For example, consider datetimes with timezones. NumPy doesn't have a dtype to represent timezone-aware datetimes, so there are two possibly useful representations:"
msgstr ""

#: ../../source/user_guide/basics.rst:90
msgid "An object-dtype :class:`numpy.ndarray` with :class:`Timestamp` objects, each with the correct ``tz``"
msgstr ""

#: ../../source/user_guide/basics.rst:92
msgid "A ``datetime64[ns]`` -dtype :class:`numpy.ndarray`, where the values have been converted to UTC and the timezone discarded"
msgstr ""

#: ../../source/user_guide/basics.rst:95
msgid "Timezones may be preserved with ``dtype=object``"
msgstr ""

#: ../../source/user_guide/basics.rst:102
msgid "Or thrown away with ``dtype='datetime64[ns]'``"
msgstr ""

#: ../../source/user_guide/basics.rst:108
msgid "Getting the \"raw data\" inside a :class:`DataFrame` is possibly a bit more complex. When your ``DataFrame`` only has a single data type for all the columns, :meth:`DataFrame.to_numpy` will return the underlying data:"
msgstr ""

#: ../../source/user_guide/basics.rst:116
msgid "If a DataFrame contains homogeneously-typed data, the ndarray can actually be modified in-place, and the changes will be reflected in the data structure. For heterogeneous data (e.g. some of the DataFrame's columns are not all the same dtype), this will not be the case. The values attribute itself, unlike the axis labels, cannot be assigned to."
msgstr ""

#: ../../source/user_guide/basics.rst:124
msgid "When working with heterogeneous data, the dtype of the resulting ndarray will be chosen to accommodate all of the data involved. For example, if strings are involved, the result will be of object dtype. If there are only floats and integers, the resulting array will be of float dtype."
msgstr ""

#: ../../source/user_guide/basics.rst:129
msgid "In the past, pandas recommended :attr:`Series.values` or :attr:`DataFrame.values` for extracting the data from a Series or DataFrame. You'll still find references to these in old code bases and online. Going forward, we recommend avoiding ``.values`` and using ``.array`` or ``.to_numpy()``. ``.values`` has the following drawbacks:"
msgstr ""

#: ../../source/user_guide/basics.rst:135
msgid "When your Series contains an :ref:`extension type <extending.extension-types>`, it's unclear whether :attr:`Series.values` returns a NumPy array or the extension array. :attr:`Series.array` will always return an :class:`~pandas.api.extensions.ExtensionArray`, and will never copy data. :meth:`Series.to_numpy` will always return a NumPy array, potentially at the cost of copying / coercing values."
msgstr ""

#: ../../source/user_guide/basics.rst:140
msgid "When your DataFrame contains a mixture of data types, :attr:`DataFrame.values` may involve copying data and coercing values to a common dtype, a relatively expensive operation. :meth:`DataFrame.to_numpy`, being a method, makes it clearer that the returned NumPy array may not be a view on the same data in the DataFrame."
msgstr ""

#: ../../source/user_guide/basics.rst:148
msgid "Accelerated operations"
msgstr ""

#: ../../source/user_guide/basics.rst:150
msgid "pandas has support for accelerating certain types of binary numerical and boolean operations using the ``numexpr`` library and the ``bottleneck`` libraries."
msgstr ""

#: ../../source/user_guide/basics.rst:153
msgid "These libraries are especially useful when dealing with large data sets, and provide large speedups. ``numexpr`` uses smart chunking, caching, and multiple cores. ``bottleneck`` is a set of specialized cython routines that are especially fast when dealing with arrays that have ``nans``."
msgstr ""

#: ../../source/user_guide/basics.rst:158
msgid "Here is a sample (using 100 column x 100,000 row ``DataFrames``):"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "Operation"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "0.11.0 (ms)"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "Prior Version (ms)"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "Ratio to Prior"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "``df1 > df2``"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "13.32"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "125.35"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "0.1063"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "``df1 * df2``"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "21.71"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "36.63"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "0.5928"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "``df1 + df2``"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "22.04"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "36.50"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "0.6039"
msgstr ""

#: ../../source/user_guide/basics.rst:169
msgid "You are highly encouraged to install both libraries. See the section :ref:`Recommended Dependencies <install.recommended_dependencies>` for more installation info."
msgstr ""

#: ../../source/user_guide/basics.rst:172
msgid "These are both enabled to be used by default, you can control this by setting the options:"
msgstr ""

#: ../../source/user_guide/basics.rst:182
msgid "Flexible binary operations"
msgstr ""

#: ../../source/user_guide/basics.rst:184
msgid "With binary operations between pandas data structures, there are two key points of interest:"
msgstr ""

#: ../../source/user_guide/basics.rst:187
msgid "Broadcasting behavior between higher- (e.g. DataFrame) and lower-dimensional (e.g. Series) objects."
msgstr ""

#: ../../source/user_guide/basics.rst:189
msgid "Missing data in computations."
msgstr ""

#: ../../source/user_guide/basics.rst:191
msgid "We will demonstrate how to manage these issues independently, though they can be handled simultaneously."
msgstr ""

#: ../../source/user_guide/basics.rst:195
msgid "Matching / broadcasting behavior"
msgstr ""

#: ../../source/user_guide/basics.rst:197
msgid "DataFrame has the methods :meth:`~DataFrame.add`, :meth:`~DataFrame.sub`, :meth:`~DataFrame.mul`, :meth:`~DataFrame.div` and related functions :meth:`~DataFrame.radd`, :meth:`~DataFrame.rsub`, ... for carrying out binary operations. For broadcasting behavior, Series input is of primary interest. Using these functions, you can use to either match on the *index* or *columns* via the **axis** keyword:"
msgstr ""

#: ../../source/user_guide/basics.rst:223
msgid "Furthermore you can align a level of a MultiIndexed DataFrame with a Series."
msgstr ""

#: ../../source/user_guide/basics.rst:233
msgid "Series and Index also support the :func:`divmod` builtin. This function takes the floor division and modulo operation at the same time returning a two-tuple of the same type as the left hand side. For example:"
msgstr ""

#: ../../source/user_guide/basics.rst:251
msgid "We can also do elementwise :func:`divmod`:"
msgstr ""

#: ../../source/user_guide/basics.rst:260
msgid "Missing data / operations with fill values"
msgstr ""

#: ../../source/user_guide/basics.rst:262
msgid "In Series and DataFrame, the arithmetic functions have the option of inputting a *fill_value*, namely a value to substitute when at most one of the values at a location are missing. For example, when adding two DataFrame objects, you may wish to treat NaN as 0 unless both DataFrames are missing that value, in which case the result will be NaN (you can later replace NaN with some other value using ``fillna`` if you wish)."
msgstr ""

#: ../../source/user_guide/basics.rst:281
msgid "Flexible comparisons"
msgstr ""

#: ../../source/user_guide/basics.rst:283
msgid "Series and DataFrame have the binary comparison methods ``eq``, ``ne``, ``lt``, ``gt``, ``le``, and ``ge`` whose behavior is analogous to the binary arithmetic operations described above:"
msgstr ""

#: ../../source/user_guide/basics.rst:292
msgid "These operations produce a pandas object of the same type as the left-hand-side input that is of dtype ``bool``. These ``boolean`` objects can be used in indexing operations, see the section on :ref:`Boolean indexing<indexing.boolean>`."
msgstr ""

#: ../../source/user_guide/basics.rst:299
msgid "Boolean reductions"
msgstr ""

#: ../../source/user_guide/basics.rst:301
msgid "You can apply the reductions: :attr:`~DataFrame.empty`, :meth:`~DataFrame.any`, :meth:`~DataFrame.all`, and :meth:`~DataFrame.bool` to provide a way to summarize a boolean result."
msgstr ""

#: ../../source/user_guide/basics.rst:310
msgid "You can reduce to a final boolean value."
msgstr ""

#: ../../source/user_guide/basics.rst:316
msgid "You can test if a pandas object is empty, via the :attr:`~DataFrame.empty` property."
msgstr ""

#: ../../source/user_guide/basics.rst:325
msgid "Asserting the truthiness of a pandas object will raise an error, as the testing of the emptiness or values is ambiguous."
msgstr ""

#: ../../source/user_guide/basics.rst:339
msgid "See :ref:`gotchas<gotchas.truth>` for a more detailed discussion."
msgstr ""

#: ../../source/user_guide/basics.rst:344
msgid "Comparing if objects are equivalent"
msgstr ""

#: ../../source/user_guide/basics.rst:346
msgid "Often you may find that there is more than one way to compute the same result.  As a simple example, consider ``df + df`` and ``df * 2``. To test that these two computations produce the same result, given the tools shown above, you might imagine using ``(df + df == df * 2).all()``. But in fact, this expression is False:"
msgstr ""

#: ../../source/user_guide/basics.rst:357
msgid "Notice that the boolean DataFrame ``df + df == df * 2`` contains some False values! This is because NaNs do not compare as equals:"
msgstr ""

#: ../../source/user_guide/basics.rst:364
msgid "So, NDFrames (such as Series and DataFrames) have an :meth:`~DataFrame.equals` method for testing equality, with NaNs in corresponding locations treated as equal."
msgstr ""

#: ../../source/user_guide/basics.rst:372
msgid "Note that the Series or DataFrame index needs to be in the same order for equality to be True:"
msgstr ""

#: ../../source/user_guide/basics.rst:383
msgid "Comparing array-like objects"
msgstr ""

#: ../../source/user_guide/basics.rst:385
msgid "You can conveniently perform element-wise comparisons when comparing a pandas data structure with a scalar value:"
msgstr ""

#: ../../source/user_guide/basics.rst:393
msgid "pandas also handles element-wise comparisons between different array-like objects of the same length:"
msgstr ""

#: ../../source/user_guide/basics.rst:401
msgid "Trying to compare ``Index`` or ``Series`` objects of different lengths will raise a ValueError:"
msgstr ""

#: ../../source/user_guide/basics.rst:412
msgid "Combining overlapping data sets"
msgstr ""

#: ../../source/user_guide/basics.rst:414
msgid "A problem occasionally arising is the combination of two similar data sets where values in one are preferred over the other. An example would be two data series representing a particular economic indicator where one is considered to be of \"higher quality\". However, the lower quality series might extend further back in history or have more complete data coverage. As such, we would like to combine two DataFrame objects where missing values in one DataFrame are conditionally filled with like-labeled values from the other DataFrame. The function implementing this operation is :meth:`~DataFrame.combine_first`, which we illustrate:"
msgstr ""

#: ../../source/user_guide/basics.rst:440
msgid "General DataFrame combine"
msgstr ""

#: ../../source/user_guide/basics.rst:442
msgid "The :meth:`~DataFrame.combine_first` method above calls the more general :meth:`DataFrame.combine`. This method takes another DataFrame and a combiner function, aligns the input DataFrame and then passes the combiner function pairs of Series (i.e., columns whose names are the same)."
msgstr ""

#: ../../source/user_guide/basics.rst:447
msgid "So, for instance, to reproduce :meth:`~DataFrame.combine_first` as above:"
msgstr ""

#: ../../source/user_guide/basics.rst:460
msgid "Descriptive statistics"
msgstr ""

#: ../../source/user_guide/basics.rst:462
msgid "There exists a large number of methods for computing descriptive statistics and other related operations on :ref:`Series <api.series.stats>`, :ref:`DataFrame <api.dataframe.stats>`. Most of these are aggregations (hence producing a lower-dimensional result) like :meth:`~DataFrame.sum`, :meth:`~DataFrame.mean`, and :meth:`~DataFrame.quantile`, but some of them, like :meth:`~DataFrame.cumsum` and :meth:`~DataFrame.cumprod`, produce an object of the same size. Generally speaking, these methods take an **axis** argument, just like *ndarray.{sum, std, ...}*, but the axis can be specified by name or integer:"
msgstr ""

#: ../../source/user_guide/basics.rst:472
msgid "**Series**: no axis argument needed"
msgstr ""

#: ../../source/user_guide/basics.rst:473
msgid "**DataFrame**: \"index\" (axis=0, default), \"columns\" (axis=1)"
msgstr ""

#: ../../source/user_guide/basics.rst:475
#: ../../source/user_guide/basics.rst:1535
msgid "For example:"
msgstr ""

#: ../../source/user_guide/basics.rst:483
msgid "All such methods have a ``skipna`` option signaling whether to exclude missing data (``True`` by default):"
msgstr ""

#: ../../source/user_guide/basics.rst:491
msgid "Combined with the broadcasting / arithmetic behavior, one can describe various statistical procedures, like standardization (rendering data zero mean and standard deviation of 1), very concisely:"
msgstr ""

#: ../../source/user_guide/basics.rst:502
msgid "Note that methods like :meth:`~DataFrame.cumsum` and :meth:`~DataFrame.cumprod` preserve the location of ``NaN`` values. This is somewhat different from :meth:`~DataFrame.expanding` and :meth:`~DataFrame.rolling` since ``NaN`` behavior is furthermore dictated by a ``min_periods`` parameter."
msgstr ""

#: ../../source/user_guide/basics.rst:511
msgid "Here is a quick reference summary table of common functions. Each also takes an optional ``level`` parameter which applies only if the object has a :ref:`hierarchical index<advanced.hierarchical>`."
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "Function"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "Description"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "``count``"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "Number of non-NA observations"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "``sum``"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "Sum of values"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "``mean``"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "Mean of values"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "``median``"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "Arithmetic median of values"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "``min``"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "Minimum"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "``max``"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "Maximum"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "``mode``"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "Mode"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "``abs``"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "Absolute Value"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "``prod``"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "Product of values"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "``std``"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "Bessel-corrected sample standard deviation"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "``var``"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "Unbiased variance"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "``sem``"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "Standard error of the mean"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "``skew``"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "Sample skewness (3rd moment)"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "``kurt``"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "Sample kurtosis (4th moment)"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "``quantile``"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "Sample quantile (value at %)"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "``cumsum``"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "Cumulative sum"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "``cumprod``"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "Cumulative product"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "``cummax``"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "Cumulative maximum"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "``cummin``"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "Cumulative minimum"
msgstr ""

#: ../../source/user_guide/basics.rst:539
msgid "Note that by chance some NumPy methods, like ``mean``, ``std``, and ``sum``, will exclude NAs on Series input by default:"
msgstr ""

#: ../../source/user_guide/basics.rst:547
msgid ":meth:`Series.nunique` will return the number of unique non-NA values in a Series:"
msgstr ""

#: ../../source/user_guide/basics.rst:560
msgid "Summarizing data: describe"
msgstr ""

#: ../../source/user_guide/basics.rst:562
msgid "There is a convenient :meth:`~DataFrame.describe` function which computes a variety of summary statistics about a Series or the columns of a DataFrame (excluding NAs of course):"
msgstr ""

#: ../../source/user_guide/basics.rst:575
msgid "You can select specific percentiles to include in the output:"
msgstr ""

#: ../../source/user_guide/basics.rst:581
msgid "By default, the median is always included."
msgstr ""

#: ../../source/user_guide/basics.rst:583
msgid "For a non-numerical Series object, :meth:`~Series.describe` will give a simple summary of the number of unique values and most frequently occurring values:"
msgstr ""

#: ../../source/user_guide/basics.rst:591
msgid "Note that on a mixed-type DataFrame object, :meth:`~DataFrame.describe` will restrict the summary to include only numerical columns or, if none are, only categorical columns:"
msgstr ""

#: ../../source/user_guide/basics.rst:600
msgid "This behavior can be controlled by providing a list of types as ``include``/``exclude`` arguments. The special value ``all`` can also be used:"
msgstr ""

#: ../../source/user_guide/basics.rst:609
msgid "That feature relies on :ref:`select_dtypes <basics.selectdtypes>`. Refer to there for details about accepted inputs."
msgstr ""

#: ../../source/user_guide/basics.rst:615
msgid "Index of min/max values"
msgstr ""

#: ../../source/user_guide/basics.rst:617
msgid "The :meth:`~DataFrame.idxmin` and :meth:`~DataFrame.idxmax` functions on Series and DataFrame compute the index labels with the minimum and maximum corresponding values:"
msgstr ""

#: ../../source/user_guide/basics.rst:632
msgid "When there are multiple rows (or columns) matching the minimum or maximum value, :meth:`~DataFrame.idxmin` and :meth:`~DataFrame.idxmax` return the first matching index:"
msgstr ""

#: ../../source/user_guide/basics.rst:644
msgid "``idxmin`` and ``idxmax`` are called ``argmin`` and ``argmax`` in NumPy."
msgstr ""

#: ../../source/user_guide/basics.rst:649
msgid "Value counts (histogramming) / mode"
msgstr ""

#: ../../source/user_guide/basics.rst:651
msgid "The :meth:`~Series.value_counts` Series method computes a histogram of a 1D array of values. It can also be used as a function on regular arrays:"
msgstr ""

#: ../../source/user_guide/basics.rst:661
msgid "The :meth:`~DataFrame.value_counts` method can be used to count combinations across multiple columns. By default all columns are used but a subset can be selected using the ``subset`` argument."
msgstr ""

#: ../../source/user_guide/basics.rst:670
msgid "Similarly, you can get the most frequently occurring value(s), i.e. the mode, of the values in a Series or DataFrame:"
msgstr ""

#: ../../source/user_guide/basics.rst:686
msgid "Discretization and quantiling"
msgstr ""

#: ../../source/user_guide/basics.rst:688
msgid "Continuous values can be discretized using the :func:`cut` (bins based on values) and :func:`qcut` (bins based on sample quantiles) functions:"
msgstr ""

#: ../../source/user_guide/basics.rst:700
msgid ":func:`qcut` computes sample quantiles. For example, we could slice up some normally distributed data into equal-size quartiles like so:"
msgstr ""

#: ../../source/user_guide/basics.rst:709
msgid "We can also pass infinite values to define the bins:"
msgstr ""

#: ../../source/user_guide/basics.rst:720
msgid "Function application"
msgstr ""

#: ../../source/user_guide/basics.rst:722
msgid "To apply your own or another library's functions to pandas objects, you should be aware of the three methods below. The appropriate method to use depends on whether your function expects to operate on an entire ``DataFrame`` or ``Series``, row- or column-wise, or elementwise."
msgstr ""

#: ../../source/user_guide/basics.rst:727
msgid "`Tablewise Function Application`_: :meth:`~DataFrame.pipe`"
msgstr ""

#: ../../source/user_guide/basics.rst:728
msgid "`Row or Column-wise Function Application`_: :meth:`~DataFrame.apply`"
msgstr ""

#: ../../source/user_guide/basics.rst:729
msgid "`Aggregation API`_: :meth:`~DataFrame.agg` and :meth:`~DataFrame.transform`"
msgstr ""

#: ../../source/user_guide/basics.rst:730
msgid "`Applying Elementwise Functions`_: :meth:`~DataFrame.map`"
msgstr ""

#: ../../source/user_guide/basics.rst:735
msgid "Tablewise function application"
msgstr ""

#: ../../source/user_guide/basics.rst:737
msgid "``DataFrames`` and ``Series`` can be passed into functions. However, if the function needs to be called in a chain, consider using the :meth:`~DataFrame.pipe` method."
msgstr ""

#: ../../source/user_guide/basics.rst:740
msgid "First some setup:"
msgstr ""

#: ../../source/user_guide/basics.rst:764
msgid "``extract_city_name`` and ``add_country_name`` are functions taking and returning ``DataFrames``."
msgstr ""

#: ../../source/user_guide/basics.rst:766
msgid "Now compare the following:"
msgstr ""

#: ../../source/user_guide/basics.rst:772
msgid "Is equivalent to:"
msgstr ""

#: ../../source/user_guide/basics.rst:778
msgid "pandas encourages the second style, which is known as method chaining. ``pipe`` makes it easy to use your own or another library's functions in method chains, alongside pandas' methods."
msgstr ""

#: ../../source/user_guide/basics.rst:782
msgid "In the example above, the functions ``extract_city_name`` and ``add_country_name`` each expected a ``DataFrame`` as the first positional argument. What if the function you wish to apply takes its data as, say, the second argument? In this case, provide ``pipe`` with a tuple of ``(callable, data_keyword)``. ``.pipe`` will route the ``DataFrame`` to the argument specified in the tuple."
msgstr ""

#: ../../source/user_guide/basics.rst:787
msgid "For example, we can fit a regression using statsmodels. Their API expects a formula first and a ``DataFrame`` as the second argument, ``data``. We pass in the function, keyword pair ``(sm.ols, 'data')`` to ``pipe``:"
msgstr ""

#: ../../source/user_guide/basics.rst:838
msgid "The pipe method is inspired by unix pipes and more recently dplyr_ and magrittr_, which have introduced the popular ``(%>%)`` (read pipe) operator for R_. The implementation of ``pipe`` here is quite clean and feels right at home in Python. We encourage you to view the source code of :meth:`~DataFrame.pipe`."
msgstr ""

#: ../../source/user_guide/basics.rst:849
msgid "Row or column-wise function application"
msgstr ""

#: ../../source/user_guide/basics.rst:851
msgid "Arbitrary functions can be applied along the axes of a DataFrame using the :meth:`~DataFrame.apply` method, which, like the descriptive statistics methods, takes an optional ``axis`` argument:"
msgstr ""

#: ../../source/user_guide/basics.rst:863
msgid "The :meth:`~DataFrame.apply` method will also dispatch on a string method name."
msgstr ""

#: ../../source/user_guide/basics.rst:870
msgid "The return type of the function passed to :meth:`~DataFrame.apply` affects the type of the final output from ``DataFrame.apply`` for the default behaviour:"
msgstr ""

#: ../../source/user_guide/basics.rst:873
msgid "If the applied function returns a ``Series``, the final output is a ``DataFrame``. The columns match the index of the ``Series`` returned by the applied function."
msgstr ""

#: ../../source/user_guide/basics.rst:875
msgid "If the applied function returns any other type, the final output is a ``Series``."
msgstr ""

#: ../../source/user_guide/basics.rst:877
msgid "This default behaviour can be overridden using the ``result_type``, which accepts three options: ``reduce``, ``broadcast``, and ``expand``. These will determine how list-likes return values expand (or not) to a ``DataFrame``."
msgstr ""

#: ../../source/user_guide/basics.rst:881
msgid ":meth:`~DataFrame.apply` combined with some cleverness can be used to answer many questions about a data set. For example, suppose we wanted to extract the date where the maximum value for each column occurred:"
msgstr ""

#: ../../source/user_guide/basics.rst:894
msgid "You may also pass additional arguments and keyword arguments to the :meth:`~DataFrame.apply` method."
msgstr ""

#: ../../source/user_guide/basics.rst:905
msgid "Another useful feature is the ability to pass Series methods to carry out some Series operation on each column or row:"
msgstr ""

#: ../../source/user_guide/basics.rst:920
msgid "Finally, :meth:`~DataFrame.apply` takes an argument ``raw`` which is False by default, which converts each row or column into a Series before applying the function. When set to True, the passed function will instead receive an ndarray object, which has positive performance implications if you do not need the indexing functionality."
msgstr ""

#: ../../source/user_guide/basics.rst:929
msgid "Aggregation API"
msgstr ""

#: ../../source/user_guide/basics.rst:931
msgid "The aggregation API allows one to express possibly multiple aggregation operations in a single concise way. This API is similar across pandas objects, see :ref:`groupby API <groupby.aggregate>`, the :ref:`window API <window.overview>`, and the :ref:`resample API <timeseries.aggregate>`. The entry point for aggregation is :meth:`DataFrame.aggregate`, or the alias :meth:`DataFrame.agg`."
msgstr ""

#: ../../source/user_guide/basics.rst:937
msgid "We will use a similar starting frame from above:"
msgstr ""

#: ../../source/user_guide/basics.rst:949
msgid "Using a single function is equivalent to :meth:`~DataFrame.apply`. You can also pass named methods as strings. These will return a ``Series`` of the aggregated output:"
msgstr ""

#: ../../source/user_guide/basics.rst:963
msgid "Single aggregations on a ``Series`` this will return a scalar value:"
msgstr ""

#: ../../source/user_guide/basics.rst:971
msgid "Aggregating with multiple functions"
msgstr ""

#: ../../source/user_guide/basics.rst:973
msgid "You can pass multiple aggregation arguments as a list. The results of each of the passed functions will be a row in the resulting ``DataFrame``. These are naturally named from the aggregation function."
msgstr ""

#: ../../source/user_guide/basics.rst:981
msgid "Multiple functions yield multiple rows:"
msgstr ""

#: ../../source/user_guide/basics.rst:987
msgid "On a ``Series``, multiple functions return a ``Series``, indexed by the function names:"
msgstr ""

#: ../../source/user_guide/basics.rst:993
msgid "Passing a ``lambda`` function will yield a ``<lambda>`` named row:"
msgstr ""

#: ../../source/user_guide/basics.rst:999
msgid "Passing a named function will yield that name for the row:"
msgstr ""

#: ../../source/user_guide/basics.rst:1010
msgid "Aggregating with a dict"
msgstr ""

#: ../../source/user_guide/basics.rst:1012
msgid "Passing a dictionary of column names to a scalar or a list of scalars, to ``DataFrame.agg`` allows you to customize which functions are applied to which columns. Note that the results are not in any particular order, you can use an ``OrderedDict`` instead to guarantee ordering."
msgstr ""

#: ../../source/user_guide/basics.rst:1020
msgid "Passing a list-like will generate a ``DataFrame`` output. You will get a matrix-like output of all of the aggregators. The output will consist of all unique functions. Those that are not noted for a particular column will be ``NaN``:"
msgstr ""

#: ../../source/user_guide/basics.rst:1031
msgid "Custom describe"
msgstr ""

#: ../../source/user_guide/basics.rst:1033
msgid "With ``.agg()`` it is possible to easily create a custom describe function, similar to the built in :ref:`describe function <basics.describe>`."
msgstr ""

#: ../../source/user_guide/basics.rst:1050
msgid "Transform API"
msgstr ""

#: ../../source/user_guide/basics.rst:1052
msgid "The :meth:`~DataFrame.transform` method returns an object that is indexed the same (same size) as the original. This API allows you to provide *multiple* operations at the same time rather than one-by-one. Its API is quite similar to the ``.agg`` API."
msgstr ""

#: ../../source/user_guide/basics.rst:1056
msgid "We create a frame similar to the one used in the above sections."
msgstr ""

#: ../../source/user_guide/basics.rst:1068
msgid "Transform the entire frame. ``.transform()`` allows input functions as: a NumPy function, a string function name or a user defined function."
msgstr ""

#: ../../source/user_guide/basics.rst:1078
msgid "Here :meth:`~DataFrame.transform` received a single function; this is equivalent to a `ufunc <https://numpy.org/doc/stable/reference/ufuncs.html>`__ application."
msgstr ""

#: ../../source/user_guide/basics.rst:1085
msgid "Passing a single function to ``.transform()`` with a ``Series`` will yield a single ``Series`` in return."
msgstr ""

#: ../../source/user_guide/basics.rst:1093
msgid "Transform with multiple functions"
msgstr ""

#: ../../source/user_guide/basics.rst:1095
msgid "Passing multiple functions will yield a column MultiIndexed DataFrame. The first level will be the original frame column names; the second level will be the names of the transforming functions."
msgstr ""

#: ../../source/user_guide/basics.rst:1103
msgid "Passing multiple functions to a Series will yield a DataFrame. The resulting column names will be the transforming functions."
msgstr ""

#: ../../source/user_guide/basics.rst:1112
msgid "Transforming with a dict"
msgstr ""

#: ../../source/user_guide/basics.rst:1115
msgid "Passing a dict of functions will allow selective transforming per column."
msgstr ""

#: ../../source/user_guide/basics.rst:1121
msgid "Passing a dict of lists will generate a MultiIndexed DataFrame with these selective transforms."
msgstr ""

#: ../../source/user_guide/basics.rst:1132
msgid "Applying elementwise functions"
msgstr ""

#: ../../source/user_guide/basics.rst:1134
msgid "Since not all functions can be vectorized (accept NumPy arrays and return another array or value), the methods :meth:`~DataFrame.map` on DataFrame and analogously :meth:`~Series.map` on Series accept any Python function taking a single value and returning a single value. For example:"
msgstr ""

#: ../../source/user_guide/basics.rst:1150
msgid ":meth:`Series.map` has an additional feature; it can be used to easily \"link\" or \"map\" values defined by a secondary series. This is closely related to :ref:`merging/joining functionality <merging>`:"
msgstr ""

#: ../../source/user_guide/basics.rst:1167
msgid "Reindexing and altering labels"
msgstr ""

#: ../../source/user_guide/basics.rst:1169
msgid ":meth:`~Series.reindex` is the fundamental data alignment method in pandas. It is used to implement nearly all other features relying on label-alignment functionality. To *reindex* means to conform the data to match a given set of labels along a particular axis. This accomplishes several things:"
msgstr ""

#: ../../source/user_guide/basics.rst:1174
msgid "Reorders the existing data to match a new set of labels"
msgstr ""

#: ../../source/user_guide/basics.rst:1175
msgid "Inserts missing value (NA) markers in label locations where no data for that label existed"
msgstr ""

#: ../../source/user_guide/basics.rst:1177
msgid "If specified, **fill** data for missing labels using logic (highly relevant to working with time series data)"
msgstr ""

#: ../../source/user_guide/basics.rst:1180
msgid "Here is a simple example:"
msgstr ""

#: ../../source/user_guide/basics.rst:1188
msgid "Here, the ``f`` label was not contained in the Series and hence appears as ``NaN`` in the result."
msgstr ""

#: ../../source/user_guide/basics.rst:1191
msgid "With a DataFrame, you can simultaneously reindex the index and columns:"
msgstr ""

#: ../../source/user_guide/basics.rst:1198
msgid "Note that the ``Index`` objects containing the actual axis labels can be **shared** between objects. So if we have a Series and a DataFrame, the following can be done:"
msgstr ""

#: ../../source/user_guide/basics.rst:1208
msgid "This means that the reindexed Series's index is the same Python object as the DataFrame's index."
msgstr ""

#: ../../source/user_guide/basics.rst:1211
msgid ":meth:`DataFrame.reindex` also supports an \"axis-style\" calling convention, where you specify a single ``labels`` argument and the ``axis`` it applies to."
msgstr ""

#: ../../source/user_guide/basics.rst:1221
msgid ":ref:`MultiIndex / Advanced Indexing <advanced>` is an even more concise way of doing reindexing."
msgstr ""

#: ../../source/user_guide/basics.rst:1226
msgid "When writing performance-sensitive code, there is a good reason to spend some time becoming a reindexing ninja: **many operations are faster on pre-aligned data**. Adding two unaligned DataFrames internally triggers a reindexing step. For exploratory analysis you will hardly notice the difference (because ``reindex`` has been heavily optimized), but when CPU cycles matter sprinkling a few explicit ``reindex`` calls here and there can have an impact."
msgstr ""

#: ../../source/user_guide/basics.rst:1237
msgid "Reindexing to align with another object"
msgstr ""

#: ../../source/user_guide/basics.rst:1239
msgid "You may wish to take an object and reindex its axes to be labeled the same as another object. While the syntax for this is straightforward albeit verbose, it is a common enough operation that the :meth:`~DataFrame.reindex_like` method is available to make this simpler:"
msgstr ""

#: ../../source/user_guide/basics.rst:1255
msgid "Aligning objects with each other with ``align``"
msgstr ""

#: ../../source/user_guide/basics.rst:1257
msgid "The :meth:`~Series.align` method is the fastest way to simultaneously align two objects. It supports a ``join`` argument (related to :ref:`joining and merging <merging>`):"
msgstr ""

#: ../../source/user_guide/basics.rst:1260
msgid "``join='outer'``: take the union of the indexes (default)"
msgstr ""

#: ../../source/user_guide/basics.rst:1261
msgid "``join='left'``: use the calling object's index"
msgstr ""

#: ../../source/user_guide/basics.rst:1262
msgid "``join='right'``: use the passed object's index"
msgstr ""

#: ../../source/user_guide/basics.rst:1263
msgid "``join='inner'``: intersect the indexes"
msgstr ""

#: ../../source/user_guide/basics.rst:1265
msgid "It returns a tuple with both of the reindexed Series:"
msgstr ""

#: ../../source/user_guide/basics.rst:1278
msgid "For DataFrames, the join method will be applied to both the index and the columns by default:"
msgstr ""

#: ../../source/user_guide/basics.rst:1285
msgid "You can also pass an ``axis`` option to only align on the specified axis:"
msgstr ""

#: ../../source/user_guide/basics.rst:1293
msgid "If you pass a Series to :meth:`DataFrame.align`, you can choose to align both objects either on the DataFrame's index or columns using the ``axis`` argument:"
msgstr ""

#: ../../source/user_guide/basics.rst:1303
msgid "Filling while reindexing"
msgstr ""

#: ../../source/user_guide/basics.rst:1305
msgid ":meth:`~Series.reindex` takes an optional parameter ``method`` which is a filling method chosen from the following table:"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "Method"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "Action"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "pad / ffill"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "Fill values forward"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "bfill / backfill"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "Fill values backward"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "nearest"
msgstr ""

#: ../../source/user_guide/basics.rst:1
msgid "Fill from the nearest index value"
msgstr ""

#: ../../source/user_guide/basics.rst:1316
msgid "We illustrate these fill methods on a simple Series:"
msgstr ""

#: ../../source/user_guide/basics.rst:1331
msgid "These methods require that the indexes are **ordered** increasing or decreasing."
msgstr ""

#: ../../source/user_guide/basics.rst:1334
msgid "Note that the same result could have been achieved using :ref:`ffill <missing_data.fillna>` (except for ``method='nearest'``) or :ref:`interpolate <missing_data.interpolate>`:"
msgstr ""

#: ../../source/user_guide/basics.rst:1342
msgid ":meth:`~Series.reindex` will raise a ValueError if the index is not monotonically increasing or decreasing. :meth:`~Series.fillna` and :meth:`~Series.interpolate` will not perform any checks on the order of the index."
msgstr ""

#: ../../source/user_guide/basics.rst:1349
msgid "Limits on filling while reindexing"
msgstr ""

#: ../../source/user_guide/basics.rst:1351
msgid "The ``limit`` and ``tolerance`` arguments provide additional control over filling while reindexing. Limit specifies the maximum count of consecutive matches:"
msgstr ""

#: ../../source/user_guide/basics.rst:1359
msgid "In contrast, tolerance specifies the maximum distance between the index and indexer values:"
msgstr ""

#: ../../source/user_guide/basics.rst:1366
msgid "Notice that when used on a ``DatetimeIndex``, ``TimedeltaIndex`` or ``PeriodIndex``, ``tolerance`` will coerced into a ``Timedelta`` if possible. This allows you to specify tolerance with appropriate strings."
msgstr ""

#: ../../source/user_guide/basics.rst:1373
msgid "Dropping labels from an axis"
msgstr ""

#: ../../source/user_guide/basics.rst:1375
msgid "A method closely related to ``reindex`` is the :meth:`~DataFrame.drop` function. It removes a set of labels from an axis:"
msgstr ""

#: ../../source/user_guide/basics.rst:1384
msgid "Note that the following also works, but is a bit less obvious / clean:"
msgstr ""

#: ../../source/user_guide/basics.rst:1393
msgid "Renaming / mapping labels"
msgstr ""

#: ../../source/user_guide/basics.rst:1395
msgid "The :meth:`~DataFrame.rename` method allows you to relabel an axis based on some mapping (a dict or Series) or an arbitrary function."
msgstr ""

#: ../../source/user_guide/basics.rst:1403
msgid "If you pass a function, it must return a value when called with any of the labels (and must produce a set of unique values). A dict or Series can also be used:"
msgstr ""

#: ../../source/user_guide/basics.rst:1414
msgid "If the mapping doesn't include a column/index label, it isn't renamed. Note that extra labels in the mapping don't throw an error."
msgstr ""

#: ../../source/user_guide/basics.rst:1417
msgid ":meth:`DataFrame.rename` also supports an \"axis-style\" calling convention, where you specify a single ``mapper`` and the ``axis`` to apply that mapping to."
msgstr ""

#: ../../source/user_guide/basics.rst:1425
msgid "Finally, :meth:`~Series.rename` also accepts a scalar or list-like for altering the ``Series.name`` attribute."
msgstr ""

#: ../../source/user_guide/basics.rst:1434
msgid "The methods :meth:`DataFrame.rename_axis` and :meth:`Series.rename_axis` allow specific names of a ``MultiIndex`` to be changed (as opposed to the labels)."
msgstr ""

#: ../../source/user_guide/basics.rst:1453
msgid "Iteration"
msgstr ""

#: ../../source/user_guide/basics.rst:1455
msgid "The behavior of basic iteration over pandas objects depends on the type. When iterating over a Series, it is regarded as array-like, and basic iteration produces the values. DataFrames follow the dict-like convention of iterating over the \"keys\" of the objects."
msgstr ""

#: ../../source/user_guide/basics.rst:1460
msgid "In short, basic iteration (``for i in object``) produces:"
msgstr ""

#: ../../source/user_guide/basics.rst:1462
msgid "**Series**: values"
msgstr ""

#: ../../source/user_guide/basics.rst:1463
msgid "**DataFrame**: column labels"
msgstr ""

#: ../../source/user_guide/basics.rst:1465
msgid "Thus, for example, iterating over a DataFrame gives you the column names:"
msgstr ""

#: ../../source/user_guide/basics.rst:1477
msgid "pandas objects also have the dict-like :meth:`~DataFrame.items` method to iterate over the (key, value) pairs."
msgstr ""

#: ../../source/user_guide/basics.rst:1480
msgid "To iterate over the rows of a DataFrame, you can use the following methods:"
msgstr ""

#: ../../source/user_guide/basics.rst:1482
msgid ":meth:`~DataFrame.iterrows`: Iterate over the rows of a DataFrame as (index, Series) pairs. This converts the rows to Series objects, which can change the dtypes and has some performance implications."
msgstr ""

#: ../../source/user_guide/basics.rst:1485
msgid ":meth:`~DataFrame.itertuples`: Iterate over the rows of a DataFrame as namedtuples of the values.  This is a lot faster than :meth:`~DataFrame.iterrows`, and is in most cases preferable to use to iterate over the values of a DataFrame."
msgstr ""

#: ../../source/user_guide/basics.rst:1492
msgid "Iterating through pandas objects is generally **slow**. In many cases, iterating manually over the rows is not needed and can be avoided with one of the following approaches:"
msgstr ""

#: ../../source/user_guide/basics.rst:1496
msgid "Look for a *vectorized* solution: many operations can be performed using built-in methods or NumPy functions, (boolean) indexing, ..."
msgstr ""

#: ../../source/user_guide/basics.rst:1499
msgid "When you have a function that cannot work on the full DataFrame/Series at once, it is better to use :meth:`~DataFrame.apply` instead of iterating over the values. See the docs on :ref:`function application <basics.apply>`."
msgstr ""

#: ../../source/user_guide/basics.rst:1503
msgid "If you need to do iterative manipulations on the values but performance is important, consider writing the inner loop with cython or numba. See the :ref:`enhancing performance <enhancingperf>` section for some examples of this approach."
msgstr ""

#: ../../source/user_guide/basics.rst:1510
msgid "You should **never modify** something you are iterating over. This is not guaranteed to work in all cases. Depending on the data types, the iterator returns a copy and not a view, and writing to it will have no effect!"
msgstr ""

#: ../../source/user_guide/basics.rst:1515
msgid "For example, in the following case setting the value has no effect:"
msgstr ""

#: ../../source/user_guide/basics.rst:1527
msgid "items"
msgstr ""

#: ../../source/user_guide/basics.rst:1529
msgid "Consistent with the dict-like interface, :meth:`~DataFrame.items` iterates through key-value pairs:"
msgstr ""

#: ../../source/user_guide/basics.rst:1532
msgid "**Series**: (index, scalar value) pairs"
msgstr ""

#: ../../source/user_guide/basics.rst:1533
msgid "**DataFrame**: (column, Series) pairs"
msgstr ""

#: ../../source/user_guide/basics.rst:1546
msgid "iterrows"
msgstr ""

#: ../../source/user_guide/basics.rst:1548
msgid ":meth:`~DataFrame.iterrows` allows you to iterate through the rows of a DataFrame as Series objects. It returns an iterator yielding each index value along with a Series containing the data in each row:"
msgstr ""

#: ../../source/user_guide/basics.rst:1559
msgid "Because :meth:`~DataFrame.iterrows` returns a Series for each row, it does **not** preserve dtypes across the rows (dtypes are preserved across columns for DataFrames). For example,"
msgstr ""

#: ../../source/user_guide/basics.rst:1570
msgid "All values in ``row``, returned as a Series, are now upcasted to floats, also the original integer value in column ``x``:"
msgstr ""

#: ../../source/user_guide/basics.rst:1578
msgid "To preserve dtypes while iterating over the rows, it is better to use :meth:`~DataFrame.itertuples` which returns namedtuples of the values and which is generally much faster than :meth:`~DataFrame.iterrows`."
msgstr ""

#: ../../source/user_guide/basics.rst:1582
msgid "For instance, a contrived way to transpose the DataFrame would be:"
msgstr ""

#: ../../source/user_guide/basics.rst:1594
msgid "itertuples"
msgstr ""

#: ../../source/user_guide/basics.rst:1596
msgid "The :meth:`~DataFrame.itertuples` method will return an iterator yielding a namedtuple for each row in the DataFrame. The first element of the tuple will be the row's corresponding index value, while the remaining values are the row values."
msgstr ""

#: ../../source/user_guide/basics.rst:1601
msgid "For instance:"
msgstr ""

#: ../../source/user_guide/basics.rst:1608
msgid "This method does not convert the row to a Series object; it merely returns the values inside a namedtuple. Therefore, :meth:`~DataFrame.itertuples` preserves the data type of the values and is generally faster as :meth:`~DataFrame.iterrows`."
msgstr ""

#: ../../source/user_guide/basics.rst:1615
msgid "The column names will be renamed to positional names if they are invalid Python identifiers, repeated, or start with an underscore. With a large number of columns (>255), regular tuples are returned."
msgstr ""

#: ../../source/user_guide/basics.rst:1622
msgid ".dt accessor"
msgstr ""

#: ../../source/user_guide/basics.rst:1624
msgid "``Series`` has an accessor to succinctly return datetime like properties for the *values* of the Series, if it is a datetime/period like Series. This will return a Series, indexed like the existing Series."
msgstr ""

#: ../../source/user_guide/basics.rst:1637
msgid "This enables nice expressions like this:"
msgstr ""

#: ../../source/user_guide/basics.rst:1643
msgid "You can easily produces tz aware transformations:"
msgstr ""

#: ../../source/user_guide/basics.rst:1651
msgid "You can also chain these types of operations:"
msgstr ""

#: ../../source/user_guide/basics.rst:1657
msgid "You can also format datetime values as strings with :meth:`Series.dt.strftime` which supports the same format as the standard :meth:`~datetime.datetime.strftime`."
msgstr ""

#: ../../source/user_guide/basics.rst:1674
msgid "The ``.dt`` accessor works for period and timedelta dtypes."
msgstr ""

#: ../../source/user_guide/basics.rst:1695
msgid "``Series.dt`` will raise a ``TypeError`` if you access with a non-datetime-like values."
msgstr ""

#: ../../source/user_guide/basics.rst:1698
msgid "Vectorized string methods"
msgstr ""

#: ../../source/user_guide/basics.rst:1700
msgid "Series is equipped with a set of string processing methods that make it easy to operate on each element of the array. Perhaps most importantly, these methods exclude missing/NA values automatically. These are accessed via the Series's ``str`` attribute and generally have names matching the equivalent (scalar) built-in string methods. For example:"
msgstr ""

#: ../../source/user_guide/basics.rst:1713
msgid "Powerful pattern-matching methods are provided as well, but note that pattern-matching generally uses `regular expressions <https://docs.python.org/3/library/re.html>`__ by default (and in some cases always uses them)."
msgstr ""

#: ../../source/user_guide/basics.rst:1720
msgid "Prior to pandas 1.0, string methods were only available on ``object`` -dtype ``Series``. pandas 1.0 added the :class:`StringDtype` which is dedicated to strings. See :ref:`text.types` for more."
msgstr ""

#: ../../source/user_guide/basics.rst:1724
msgid "Please see :ref:`Vectorized String Methods <text.string_methods>` for a complete description."
msgstr ""

#: ../../source/user_guide/basics.rst:1730
msgid "Sorting"
msgstr ""

#: ../../source/user_guide/basics.rst:1732
msgid "pandas supports three kinds of sorting: sorting by index labels, sorting by column values, and sorting by a combination of both."
msgstr ""

#: ../../source/user_guide/basics.rst:1738
msgid "By index"
msgstr ""

#: ../../source/user_guide/basics.rst:1740
msgid "The :meth:`Series.sort_index` and :meth:`DataFrame.sort_index` methods are used to sort a pandas object by its index levels."
msgstr ""

#: ../../source/user_guide/basics.rst:1768
msgid "Sorting by index also supports a ``key`` parameter that takes a callable function to apply to the index being sorted. For ``MultiIndex`` objects, the key is applied per-level to the levels specified by ``level``."
msgstr ""

#: ../../source/user_guide/basics.rst:1784
msgid "For information on key sorting by value, see :ref:`value sorting <basics.sort_value_key>`."
msgstr ""

#: ../../source/user_guide/basics.rst:1790
msgid "By values"
msgstr ""

#: ../../source/user_guide/basics.rst:1792
msgid "The :meth:`Series.sort_values` method is used to sort a ``Series`` by its values. The :meth:`DataFrame.sort_values` method is used to sort a ``DataFrame`` by its column or row values. The optional ``by`` parameter to :meth:`DataFrame.sort_values` may used to specify one or more columns to use to determine the sorted order."
msgstr ""

#: ../../source/user_guide/basics.rst:1804
msgid "The ``by`` parameter can take a list of column names, e.g.:"
msgstr ""

#: ../../source/user_guide/basics.rst:1810
msgid "These methods have special treatment of NA values via the ``na_position`` argument:"
msgstr ""

#: ../../source/user_guide/basics.rst:1821
msgid "Sorting also supports a ``key`` parameter that takes a callable function to apply to the values being sorted."
msgstr ""

#: ../../source/user_guide/basics.rst:1833
msgid "``key`` will be given the :class:`Series` of values and should return a ``Series`` or array of the same shape with the transformed values. For ``DataFrame`` objects, the key is applied per column, so the key should still expect a Series and return a Series, e.g."
msgstr ""

#: ../../source/user_guide/basics.rst:1847
msgid "The name or type of each column can be used to apply different functions to different columns."
msgstr ""

#: ../../source/user_guide/basics.rst:1853
msgid "By indexes and values"
msgstr ""

#: ../../source/user_guide/basics.rst:1855
msgid "Strings passed as the ``by`` parameter to :meth:`DataFrame.sort_values` may refer to either columns or index level names."
msgstr ""

#: ../../source/user_guide/basics.rst:1870
msgid "Sort by 'second' (index) and 'A' (column)"
msgstr ""

#: ../../source/user_guide/basics.rst:1878
msgid "If a string matches both a column name and an index level name then a warning is issued and the column takes precedence. This will result in an ambiguity error in a future version."
msgstr ""

#: ../../source/user_guide/basics.rst:1885
msgid "searchsorted"
msgstr ""

#: ../../source/user_guide/basics.rst:1887
msgid "Series has the :meth:`~Series.searchsorted` method, which works similarly to :meth:`numpy.ndarray.searchsorted`."
msgstr ""

#: ../../source/user_guide/basics.rst:1903
msgid "smallest / largest values"
msgstr ""

#: ../../source/user_guide/basics.rst:1905
msgid "``Series`` has the :meth:`~Series.nsmallest` and :meth:`~Series.nlargest` methods which return the smallest or largest :math:`n` values. For a large ``Series`` this can be much faster than sorting the entire Series and calling ``head(n)`` on the result."
msgstr ""

#: ../../source/user_guide/basics.rst:1917
msgid "``DataFrame`` also has the ``nlargest`` and ``nsmallest`` methods."
msgstr ""

#: ../../source/user_guide/basics.rst:1937
msgid "Sorting by a MultiIndex column"
msgstr ""

#: ../../source/user_guide/basics.rst:1939
msgid "You must be explicit about sorting when the column is a MultiIndex, and fully specify all levels to ``by``."
msgstr ""

#: ../../source/user_guide/basics.rst:1951
msgid "Copying"
msgstr ""

#: ../../source/user_guide/basics.rst:1953
msgid "The :meth:`~DataFrame.copy` method on pandas objects copies the underlying data (though not the axis indexes, since they are immutable) and returns a new object. Note that **it is seldom necessary to copy objects**. For example, there are only a handful of ways to alter a DataFrame *in-place*:"
msgstr ""

#: ../../source/user_guide/basics.rst:1958
msgid "Inserting, deleting, or modifying a column."
msgstr ""

#: ../../source/user_guide/basics.rst:1959
msgid "Assigning to the ``index`` or ``columns`` attributes."
msgstr ""

#: ../../source/user_guide/basics.rst:1960
msgid "For homogeneous data, directly modifying the values via the ``values`` attribute or advanced indexing."
msgstr ""

#: ../../source/user_guide/basics.rst:1963
msgid "To be clear, no pandas method has the side effect of modifying your data; almost every method returns a new object, leaving the original object untouched. If the data is modified, it is because you did so explicitly."
msgstr ""

#: ../../source/user_guide/basics.rst:1970
msgid "dtypes"
msgstr ""

#: ../../source/user_guide/basics.rst:1972
msgid "For the most part, pandas uses NumPy arrays and dtypes for Series or individual columns of a DataFrame. NumPy provides support for ``float``, ``int``, ``bool``, ``timedelta64[ns]`` and ``datetime64[ns]`` (note that NumPy does not support timezone-aware datetimes)."
msgstr ""

#: ../../source/user_guide/basics.rst:1977
msgid "pandas and third-party libraries *extend* NumPy's type system in a few places. This section describes the extensions pandas has made internally. See :ref:`extending.extension-types` for how to write your own extension that works with pandas. See `the ecosystem page <https://pandas.pydata.org/community/ecosystem.html>`_ for a list of third-party libraries that have implemented an extension."
msgstr ""

#: ../../source/user_guide/basics.rst:1983
msgid "The following table lists all of pandas extension types. For methods requiring ``dtype`` arguments, strings can be specified as indicated. See the respective documentation sections for more on each type."
msgstr ""

#: ../../source/user_guide/basics.rst:1988
msgid "Kind of Data"
msgstr ""

#: ../../source/user_guide/basics.rst:1988
msgid "Data Type"
msgstr ""

#: ../../source/user_guide/basics.rst:1988
msgid "Scalar"
msgstr ""

#: ../../source/user_guide/basics.rst:1988
msgid "Array"
msgstr ""

#: ../../source/user_guide/basics.rst:1988
msgid "String Aliases"
msgstr ""

#: ../../source/user_guide/basics.rst:1990
msgid ":ref:`tz-aware datetime <timeseries.timezone>`"
msgstr ""

#: ../../source/user_guide/basics.rst:1990
msgid ":class:`DatetimeTZDtype`"
msgstr ""

#: ../../source/user_guide/basics.rst:1990
msgid ":class:`Timestamp`"
msgstr ""

#: ../../source/user_guide/basics.rst:1990
msgid ":class:`arrays.DatetimeArray`"
msgstr ""

#: ../../source/user_guide/basics.rst:1990
msgid "``'datetime64[ns, <tz>]'``"
msgstr ""

#: ../../source/user_guide/basics.rst:1993
msgid ":ref:`Categorical <categorical>`"
msgstr ""

#: ../../source/user_guide/basics.rst:1993
msgid ":class:`CategoricalDtype`"
msgstr ""

#: ../../source/user_guide/basics.rst:1993
#: ../../source/user_guide/basics.rst:1998
#: ../../source/user_guide/basics.rst:2006
#: ../../source/user_guide/basics.rst:2010
msgid "(none)"
msgstr ""

#: ../../source/user_guide/basics.rst:1993
msgid ":class:`Categorical`"
msgstr ""

#: ../../source/user_guide/basics.rst:1993
msgid "``'category'``"
msgstr ""

#: ../../source/user_guide/basics.rst:1995
msgid ":ref:`period (time spans) <timeseries.periods>`"
msgstr ""

#: ../../source/user_guide/basics.rst:1995
msgid ":class:`PeriodDtype`"
msgstr ""

#: ../../source/user_guide/basics.rst:1995
msgid ":class:`Period`"
msgstr ""

#: ../../source/user_guide/basics.rst:1995
msgid ":class:`arrays.PeriodArray` ``'Period[<freq>]'``"
msgstr ""

#: ../../source/user_guide/basics.rst:1995
msgid "``'period[<freq>]'``,"
msgstr ""

#: ../../source/user_guide/basics.rst:1998
msgid ":ref:`sparse <sparse>`"
msgstr ""

#: ../../source/user_guide/basics.rst:1998
msgid ":class:`SparseDtype`"
msgstr ""

#: ../../source/user_guide/basics.rst:1998
msgid ":class:`arrays.SparseArray`"
msgstr ""

#: ../../source/user_guide/basics.rst:1998
msgid "``'Sparse'``, ``'Sparse[int]'``, ``'Sparse[float]'``"
msgstr ""

#: ../../source/user_guide/basics.rst:2001
msgid ":ref:`intervals <advanced.intervalindex>`"
msgstr ""

#: ../../source/user_guide/basics.rst:2001
msgid ":class:`IntervalDtype`"
msgstr ""

#: ../../source/user_guide/basics.rst:2001
msgid ":class:`Interval`"
msgstr ""

#: ../../source/user_guide/basics.rst:2001
msgid ":class:`arrays.IntervalArray`"
msgstr ""

#: ../../source/user_guide/basics.rst:2001
msgid "``'interval'``, ``'Interval'``, ``'Interval[<numpy_dtype>]'``, ``'Interval[datetime64[ns, <tz>]]'``, ``'Interval[timedelta64[<freq>]]'``"
msgstr ""

#: ../../source/user_guide/basics.rst:2006
msgid ":ref:`nullable integer <integer_na>`"
msgstr ""

#: ../../source/user_guide/basics.rst:2006
msgid ":class:`Int64Dtype`, ..."
msgstr ""

#: ../../source/user_guide/basics.rst:2006
msgid ":class:`arrays.IntegerArray`"
msgstr ""

#: ../../source/user_guide/basics.rst:2006
msgid "``'Int8'``, ``'Int16'``, ``'Int32'``, ``'Int64'``, ``'UInt8'``, ``'UInt16'``, ``'UInt32'``, ``'UInt64'``"
msgstr ""

#: ../../source/user_guide/basics.rst:2010
msgid "``nullable float``"
msgstr ""

#: ../../source/user_guide/basics.rst:2010
msgid ":class:`Float64Dtype`, ..."
msgstr ""

#: ../../source/user_guide/basics.rst:2010
msgid ":class:`arrays.FloatingArray`"
msgstr ""

#: ../../source/user_guide/basics.rst:2010
msgid "``'Float32'``, ``'Float64'``"
msgstr ""

#: ../../source/user_guide/basics.rst:2012
msgid ":ref:`Strings <text>`"
msgstr ""

#: ../../source/user_guide/basics.rst:2012
msgid ":class:`StringDtype`"
msgstr ""

#: ../../source/user_guide/basics.rst:2012
msgid ":class:`str`"
msgstr ""

#: ../../source/user_guide/basics.rst:2012
msgid ":class:`arrays.StringArray`"
msgstr ""

#: ../../source/user_guide/basics.rst:2012
msgid "``'string'``"
msgstr ""

#: ../../source/user_guide/basics.rst:2014
msgid ":ref:`Boolean (with NA) <api.arrays.bool>`"
msgstr ""

#: ../../source/user_guide/basics.rst:2014
msgid ":class:`BooleanDtype`"
msgstr ""

#: ../../source/user_guide/basics.rst:2014
msgid ":class:`bool`"
msgstr ""

#: ../../source/user_guide/basics.rst:2014
msgid ":class:`arrays.BooleanArray`"
msgstr ""

#: ../../source/user_guide/basics.rst:2014
msgid "``'boolean'``"
msgstr ""

#: ../../source/user_guide/basics.rst:2017
msgid "pandas has two ways to store strings."
msgstr ""

#: ../../source/user_guide/basics.rst:2019
msgid "``object`` dtype, which can hold any Python object, including strings."
msgstr ""

#: ../../source/user_guide/basics.rst:2020
msgid ":class:`StringDtype`, which is dedicated to strings."
msgstr ""

#: ../../source/user_guide/basics.rst:2022
msgid "Generally, we recommend using :class:`StringDtype`. See :ref:`text.types` for more."
msgstr ""

#: ../../source/user_guide/basics.rst:2024
msgid "Finally, arbitrary objects may be stored using the ``object`` dtype, but should be avoided to the extent possible (for performance and interoperability with other libraries and methods. See :ref:`basics.object_conversion`)."
msgstr ""

#: ../../source/user_guide/basics.rst:2028
msgid "A convenient :attr:`~DataFrame.dtypes` attribute for DataFrame returns a Series with the data type of each column."
msgstr ""

#: ../../source/user_guide/basics.rst:2047
msgid "On a ``Series`` object, use the :attr:`~Series.dtype` attribute."
msgstr ""

#: ../../source/user_guide/basics.rst:2053
msgid "If a pandas object contains data with multiple dtypes *in a single column*, the dtype of the column will be chosen to accommodate all of the data types (``object`` is the most general)."
msgstr ""

#: ../../source/user_guide/basics.rst:2065
msgid "The number of columns of each type in a ``DataFrame`` can be found by calling ``DataFrame.dtypes.value_counts()``."
msgstr ""

#: ../../source/user_guide/basics.rst:2072
msgid "Numeric dtypes will propagate and can coexist in DataFrames. If a dtype is passed (either directly via the ``dtype`` keyword, a passed ``ndarray``, or a passed ``Series``), then it will be preserved in DataFrame operations. Furthermore, different numeric dtypes will **NOT** be combined. The following example will give you a taste."
msgstr ""

#: ../../source/user_guide/basics.rst:2093
msgid "defaults"
msgstr ""

#: ../../source/user_guide/basics.rst:2095
msgid "By default integer types are ``int64`` and float types are ``float64``, *regardless* of platform (32-bit or 64-bit). The following will all result in ``int64`` dtypes."
msgstr ""

#: ../../source/user_guide/basics.rst:2105
msgid "Note that Numpy will choose *platform-dependent* types when creating arrays. The following **WILL** result in ``int32`` on 32-bit platform."
msgstr ""

#: ../../source/user_guide/basics.rst:2114
msgid "upcasting"
msgstr ""

#: ../../source/user_guide/basics.rst:2116
msgid "Types can potentially be *upcasted* when combined with other types, meaning they are promoted from the current type (e.g. ``int`` to ``float``)."
msgstr ""

#: ../../source/user_guide/basics.rst:2125
msgid ":meth:`DataFrame.to_numpy` will return the *lower-common-denominator* of the dtypes, meaning the dtype that can accommodate **ALL** of the types in the resulting homogeneous dtyped NumPy array. This can force some *upcasting*."
msgstr ""

#: ../../source/user_guide/basics.rst:2134
msgid "astype"
msgstr ""

#: ../../source/user_guide/basics.rst:2138
msgid "You can use the :meth:`~DataFrame.astype` method to explicitly convert dtypes from one to another. These will by default return a copy, even if the dtype was unchanged (pass ``copy=False`` to change this behavior). In addition, they will raise an exception if the astype operation is invalid."
msgstr ""

#: ../../source/user_guide/basics.rst:2142
msgid "Upcasting is always according to the **NumPy** rules. If two different dtypes are involved in an operation, then the more *general* one will be used as the result of the operation."
msgstr ""

#: ../../source/user_guide/basics.rst:2154
msgid "Convert a subset of columns to a specified type using :meth:`~DataFrame.astype`."
msgstr ""

#: ../../source/user_guide/basics.rst:2163
msgid "Convert certain columns to a specific dtype by passing a dict to :meth:`~DataFrame.astype`."
msgstr ""

#: ../../source/user_guide/basics.rst:2174
msgid "When trying to convert a subset of columns to a specified type using :meth:`~DataFrame.astype`  and :meth:`~DataFrame.loc`, upcasting occurs."
msgstr ""

#: ../../source/user_guide/basics.rst:2176
msgid ":meth:`~DataFrame.loc` tries to fit in what we are assigning to the current dtypes, while ``[]`` will overwrite them taking the dtype from the right hand side. Therefore the following piece of code produces the unintended result."
msgstr ""

#: ../../source/user_guide/basics.rst:2188
msgid "object conversion"
msgstr ""

#: ../../source/user_guide/basics.rst:2190
msgid "pandas offers various functions to try to force conversion of types from the ``object`` dtype to other types. In cases where the data is already of the correct type, but stored in an ``object`` array, the :meth:`DataFrame.infer_objects` and :meth:`Series.infer_objects` methods can be used to soft convert to the correct type."
msgstr ""

#: ../../source/user_guide/basics.rst:2210
msgid "Because the data was transposed the original inference stored all columns as object, which ``infer_objects`` will correct."
msgstr ""

#: ../../source/user_guide/basics.rst:2217
msgid "The following functions are available for one dimensional object arrays or scalars to perform hard conversion of objects to a specified type:"
msgstr ""

#: ../../source/user_guide/basics.rst:2220
msgid ":meth:`~pandas.to_numeric` (conversion to numeric dtypes)"
msgstr ""

#: ../../source/user_guide/basics.rst:2227
msgid ":meth:`~pandas.to_datetime` (conversion to datetime objects)"
msgstr ""

#: ../../source/user_guide/basics.rst:2236
msgid ":meth:`~pandas.to_timedelta` (conversion to timedelta objects)"
msgstr ""

#: ../../source/user_guide/basics.rst:2243
msgid "To force a conversion, we can pass in an ``errors`` argument, which specifies how pandas should deal with elements that cannot be converted to desired dtype or object. By default, ``errors='raise'``, meaning that any errors encountered will be raised during the conversion process. However, if ``errors='coerce'``, these errors will be ignored and pandas will convert problematic elements to ``pd.NaT`` (for datetime and timedelta) or ``np.nan`` (for numeric). This might be useful if you are reading in data which is mostly of the desired dtype (e.g. numeric, datetime), but occasionally has non-conforming elements intermixed that you want to represent as missing:"
msgstr ""

#: ../../source/user_guide/basics.rst:2264
msgid "The ``errors`` parameter has a third option of ``errors='ignore'``, which will simply return the passed in data if it encounters any errors with the conversion to a desired data type:"
msgstr ""

#: ../../source/user_guide/basics.rst:2281
msgid "In addition to object conversion, :meth:`~pandas.to_numeric` provides another argument ``downcast``, which gives the option of downcasting the newly (or already) numeric data to a smaller dtype, which can conserve memory:"
msgstr ""

#: ../../source/user_guide/basics.rst:2292
msgid "As these methods apply only to one-dimensional arrays, lists or scalars; they cannot be used directly on multi-dimensional objects such as DataFrames. However, with :meth:`~pandas.DataFrame.apply`, we can \"apply\" the function over each column efficiently:"
msgstr ""

#: ../../source/user_guide/basics.rst:2312
msgid "gotchas"
msgstr ""

#: ../../source/user_guide/basics.rst:2314
msgid "Performing selection operations on ``integer`` type data can easily upcast the data to ``floating``. The dtype of the input data will be preserved in cases where ``nans`` are not introduced. See also :ref:`Support for integer NA <gotchas.intna>`."
msgstr ""

#: ../../source/user_guide/basics.rst:2329
msgid "While float dtypes are unchanged."
msgstr ""

#: ../../source/user_guide/basics.rst:2342
msgid "Selecting columns based on ``dtype``"
msgstr ""

#: ../../source/user_guide/basics.rst:2346
msgid "The :meth:`~DataFrame.select_dtypes` method implements subsetting of columns based on their ``dtype``."
msgstr ""

#: ../../source/user_guide/basics.rst:2349
msgid "First, let's create a :class:`DataFrame` with a slew of different dtypes:"
msgstr ""

#: ../../source/user_guide/basics.rst:2372
msgid "And the dtypes:"
msgstr ""

#: ../../source/user_guide/basics.rst:2378
msgid ":meth:`~DataFrame.select_dtypes` has two parameters ``include`` and ``exclude`` that allow you to say \"give me the columns *with* these dtypes\" (``include``) and/or \"give the columns *without* these dtypes\" (``exclude``)."
msgstr ""

#: ../../source/user_guide/basics.rst:2382
msgid "For example, to select ``bool`` columns:"
msgstr ""

#: ../../source/user_guide/basics.rst:2388
msgid "You can also pass the name of a dtype in the `NumPy dtype hierarchy <https://numpy.org/doc/stable/reference/arrays.scalars.html>`__:"
msgstr ""

#: ../../source/user_guide/basics.rst:2395
msgid ":meth:`~pandas.DataFrame.select_dtypes` also works with generic dtypes as well."
msgstr ""

#: ../../source/user_guide/basics.rst:2397
msgid "For example, to select all numeric and boolean columns while excluding unsigned integers:"
msgstr ""

#: ../../source/user_guide/basics.rst:2404
msgid "To select string columns you must use the ``object`` dtype:"
msgstr ""

#: ../../source/user_guide/basics.rst:2410
msgid "To see all the child dtypes of a generic ``dtype`` like ``numpy.number`` you can define a function that returns a tree of child dtypes:"
msgstr ""

#: ../../source/user_guide/basics.rst:2421
msgid "All NumPy dtypes are subclasses of ``numpy.generic``:"
msgstr ""

#: ../../source/user_guide/basics.rst:2429
msgid "pandas also defines the types ``category``, and ``datetime64[ns, tz]``, which are not integrated into the normal NumPy hierarchy and won't show up with the above function."
msgstr ""
