# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023
# This file is distributed under the same license as the pandas package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: pandas 2.1.3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-11-12 17:37+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../source/user_guide/io.rst:8
msgid "IO tools (text, CSV, HDF5, ...)"
msgstr ""

#: ../../source/user_guide/io.rst:10
msgid "The pandas I/O API is a set of top level ``reader`` functions accessed like :func:`pandas.read_csv` that generally return a pandas object. The corresponding ``writer`` functions are object methods that are accessed like :meth:`DataFrame.to_csv`. Below is a table containing available ``readers`` and ``writers``."
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid "Format Type"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid "Data Description"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid "Reader"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid "Writer"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid "text"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid "`CSV <https://en.wikipedia.org/wiki/Comma-separated_values>`__"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid ":ref:`read_csv<io.read_csv_table>`"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid ":ref:`to_csv<io.store_in_csv>`"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid "Fixed-Width Text File"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid ":ref:`read_fwf<io.fwf_reader>`"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid "`JSON <https://www.json.org/>`__"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid ":ref:`read_json<io.json_reader>`"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid ":ref:`to_json<io.json_writer>`"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid "`HTML <https://en.wikipedia.org/wiki/HTML>`__"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid ":ref:`read_html<io.read_html>`"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid ":ref:`to_html<io.html>`"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid "`LaTeX <https://en.wikipedia.org/wiki/LaTeX>`__"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid ":ref:`Styler.to_latex<io.latex>`"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid "`XML <https://www.w3.org/standards/xml/core>`__"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid ":ref:`read_xml<io.read_xml>`"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid ":ref:`to_xml<io.xml>`"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid "Local clipboard"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid ":ref:`read_clipboard<io.clipboard>`"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid ":ref:`to_clipboard<io.clipboard>`"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid "binary"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid "`MS Excel <https://en.wikipedia.org/wiki/Microsoft_Excel>`__"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid ":ref:`read_excel<io.excel_reader>`"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid ":ref:`to_excel<io.excel_writer>`"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid "`OpenDocument <http://opendocumentformat.org>`__"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid ":ref:`read_excel<io.ods>`"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid "`HDF5 Format <https://support.hdfgroup.org/HDF5/whatishdf5.html>`__"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid ":ref:`read_hdf<io.hdf5>`"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid ":ref:`to_hdf<io.hdf5>`"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid "`Feather Format <https://github.com/wesm/feather>`__"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid ":ref:`read_feather<io.feather>`"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid ":ref:`to_feather<io.feather>`"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid "`Parquet Format <https://parquet.apache.org/>`__"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid ":ref:`read_parquet<io.parquet>`"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid ":ref:`to_parquet<io.parquet>`"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid "`ORC Format <https://orc.apache.org/>`__"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid ":ref:`read_orc<io.orc>`"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid ":ref:`to_orc<io.orc>`"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid "`Stata <https://en.wikipedia.org/wiki/Stata>`__"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid ":ref:`read_stata<io.stata_reader>`"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid ":ref:`to_stata<io.stata_writer>`"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid "`SAS <https://en.wikipedia.org/wiki/SAS_(software)>`__"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid ":ref:`read_sas<io.sas_reader>`"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid "`SPSS <https://en.wikipedia.org/wiki/SPSS>`__"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid ":ref:`read_spss<io.spss_reader>`"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid "`Python Pickle Format <https://docs.python.org/3/library/pickle.html>`__"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid ":ref:`read_pickle<io.pickle>`"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid ":ref:`to_pickle<io.pickle>`"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid "SQL"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid "`SQL <https://en.wikipedia.org/wiki/SQL>`__"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid ":ref:`read_sql<io.sql>`"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid ":ref:`to_sql<io.sql>`"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid "`Google BigQuery <https://en.wikipedia.org/wiki/BigQuery>`__"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid ":ref:`read_gbq<io.bigquery>`"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid ":ref:`to_gbq<io.bigquery>`"
msgstr ""

#: ../../source/user_guide/io.rst:41
msgid ":ref:`Here <io.perf>` is an informal performance comparison for some of these IO methods."
msgstr ""

#: ../../source/user_guide/io.rst:44
msgid "For examples that use the ``StringIO`` class, make sure you import it with ``from io import StringIO`` for Python 3."
msgstr ""

#: ../../source/user_guide/io.rst:50
msgid "CSV & text files"
msgstr ""

#: ../../source/user_guide/io.rst:52
msgid "The workhorse function for reading text files (a.k.a. flat files) is :func:`read_csv`. See the :ref:`cookbook<cookbook.csv>` for some advanced strategies."
msgstr ""

#: ../../source/user_guide/io.rst:56
msgid "Parsing options"
msgstr ""

#: ../../source/user_guide/io.rst:58
msgid ":func:`read_csv` accepts the following common arguments:"
msgstr ""

#: ../../source/user_guide/io.rst:61
msgid "Basic"
msgstr ""

#: ../../source/user_guide/io.rst:66
msgid "filepath_or_buffer"
msgstr ""

#: ../../source/user_guide/io.rst:-1
msgid "various"
msgstr ""

#: ../../source/user_guide/io.rst:64
msgid "Either a path to a file (a :class:`python:str`, :class:`python:pathlib.Path`, or :class:`py:py._path.local.LocalPath`), URL (including http, ftp, and S3 locations), or any object with a ``read()`` method (such as an open file or :class:`~python:io.StringIO`)."
msgstr ""

#: ../../source/user_guide/io.rst:74
msgid "sep : str, defaults to ``','`` for :func:`read_csv`, ``\\t`` for :func:`read_table`"
msgstr ""

#: ../../source/user_guide/io.rst:-1
msgid "str, defaults to"
msgstr ""

#: ../../source/user_guide/io.rst:69
msgid "Delimiter to use. If sep is ``None``, the C engine cannot automatically detect the separator, but the Python parsing engine can, meaning the latter will be used and automatically detect the separator by Python's builtin sniffer tool, :class:`python:csv.Sniffer`. In addition, separators longer than 1 character and different from ``'\\s+'`` will be interpreted as regular expressions and will also force the use of the Python parsing engine. Note that regex delimiters are prone to ignoring quoted data. Regex example: ``'\\\\r\\\\t'``."
msgstr ""

#: ../../source/user_guide/io.rst:76
msgid "delimiter : str, default ``None``"
msgstr ""

#: ../../source/user_guide/io.rst:-1
msgid "str, default"
msgstr ""

#: ../../source/user_guide/io.rst:77
msgid "Alternative argument name for sep."
msgstr ""

#: ../../source/user_guide/io.rst:82
msgid "delim_whitespace"
msgstr ""

#: ../../source/user_guide/io.rst:-1
msgid "boolean, default False"
msgstr ""

#: ../../source/user_guide/io.rst:79
msgid "Specifies whether or not whitespace (e.g. ``' '`` or ``'\\t'``) will be used as the delimiter. Equivalent to setting ``sep='\\s+'``. If this option is set to ``True``, nothing should be passed in for the ``delimiter`` parameter."
msgstr ""

#: ../../source/user_guide/io.rst:85
msgid "Column and index locations and names"
msgstr ""

#: ../../source/user_guide/io.rst:100
msgid "header : int or list of ints, default ``'infer'``"
msgstr ""

#: ../../source/user_guide/io.rst:-1
msgid "int or list of ints, default"
msgstr ""

#: ../../source/user_guide/io.rst:88
msgid "Row number(s) to use as the column names, and the start of the data. Default behavior is to infer the column names: if no names are passed the behavior is identical to ``header=0`` and column names are inferred from the first line of the file, if column names are passed explicitly then the behavior is identical to ``header=None``. Explicitly pass ``header=0`` to be able to replace existing names."
msgstr ""

#: ../../source/user_guide/io.rst:96
msgid "The header can be a list of ints that specify row locations for a MultiIndex on the columns e.g. ``[0,1,3]``. Intervening rows that are not specified will be skipped (e.g. 2 in this example is skipped). Note that this parameter ignores commented lines and empty lines if ``skip_blank_lines=True``, so header=0 denotes the first line of data rather than the first line of the file."
msgstr ""

#: ../../source/user_guide/io.rst:103
msgid "names : array-like, default ``None``"
msgstr ""

#: ../../source/user_guide/io.rst:-1
msgid "array-like, default"
msgstr ""

#: ../../source/user_guide/io.rst:103
msgid "List of column names to use. If file contains no header row, then you should explicitly pass ``header=None``. Duplicates in this list are not allowed."
msgstr ""

#: ../../source/user_guide/io.rst:125
msgid "index_col : int, str, sequence of int / str, or False, optional, default ``None``"
msgstr ""

#: ../../source/user_guide/io.rst:-1
msgid "int, str, sequence of int / str, or False, optional, default"
msgstr ""

#: ../../source/user_guide/io.rst:106
msgid "Column(s) to use as the row labels of the ``DataFrame``, either given as string name or column index. If a sequence of int / str is given, a MultiIndex is used."
msgstr ""

#: ../../source/user_guide/io.rst:111
msgid "``index_col=False`` can be used to force pandas to *not* use the first column as the index, e.g. when you have a malformed file with delimiters at the end of each line."
msgstr ""

#: ../../source/user_guide/io.rst:115
msgid "The default value of ``None`` instructs pandas to guess. If the number of fields in the column header row is equal to the number of fields in the body of the data file, then a default index is used.  If it is larger, then the first columns are used as index so that the remaining number of fields in the body are equal to the number of fields in the header."
msgstr ""

#: ../../source/user_guide/io.rst:121
msgid "The first row after the header is used to determine the number of columns, which will go into the index. If the subsequent rows contain less columns than the first row, they are filled with ``NaN``."
msgstr ""

#: ../../source/user_guide/io.rst:125
msgid "This can be avoided through ``usecols``. This ensures that the columns are taken as is and the trailing data are ignored."
msgstr ""

#: ../../source/user_guide/io.rst:156
msgid "usecols : list-like or callable, default ``None``"
msgstr ""

#: ../../source/user_guide/io.rst:-1
msgid "list-like or callable, default"
msgstr ""

#: ../../source/user_guide/io.rst:128
msgid "Return a subset of the columns. If list-like, all elements must either be positional (i.e. integer indices into the document columns) or strings that correspond to column names provided either by the user in ``names`` or inferred from the document header row(s). If ``names`` are given, the document header row(s) are not taken into account. For example, a valid list-like ``usecols`` parameter would be ``[0, 1, 2]`` or ``['foo', 'bar', 'baz']``."
msgstr ""

#: ../../source/user_guide/io.rst:135
msgid "Element order is ignored, so ``usecols=[0, 1]`` is the same as ``[1, 0]``. To instantiate a DataFrame from ``data`` with element order preserved use ``pd.read_csv(data, usecols=['foo', 'bar'])[['foo', 'bar']]`` for columns in ``['foo', 'bar']`` order or ``pd.read_csv(data, usecols=['foo', 'bar'])[['bar', 'foo']]`` for ``['bar', 'foo']`` order."
msgstr ""

#: ../../source/user_guide/io.rst:142
msgid "If callable, the callable function will be evaluated against the column names, returning names where the callable function evaluates to True:"
msgstr ""

#: ../../source/user_guide/io.rst:154
msgid "Using this parameter results in much faster parsing time and lower memory usage when using the c engine. The Python engine loads the data first before deciding which columns to drop."
msgstr ""

#: ../../source/user_guide/io.rst:159
msgid "General parsing configuration"
msgstr ""

#: ../../source/user_guide/io.rst:171
msgid "dtype : Type name or dict of column -> type, default ``None``"
msgstr ""

#: ../../source/user_guide/io.rst:-1
msgid "Type name or dict of column -> type, default"
msgstr ""

#: ../../source/user_guide/io.rst:162
msgid "Data type for data or columns. E.g. ``{'a': np.float64, 'b': np.int32, 'c': 'Int64'}`` Use ``str`` or ``object`` together with suitable ``na_values`` settings to preserve and not interpret dtype. If converters are specified, they will be applied INSTEAD of dtype conversion."
msgstr ""

#: ../../source/user_guide/io.rst:169
msgid "Support for defaultdict was added. Specify a defaultdict as input where the default determines the dtype of the columns which are not explicitly listed."
msgstr ""

#: ../../source/user_guide/io.rst:181
msgid "dtype_backend"
msgstr ""

#: ../../source/user_guide/io.rst:-1
msgid "{\"numpy_nullable\", \"pyarrow\"}, defaults to NumPy backed DataFrames"
msgstr ""

#: ../../source/user_guide/io.rst:174
msgid "Which dtype_backend to use, e.g. whether a DataFrame should have NumPy arrays, nullable dtypes are used for all dtypes that have a nullable implementation when \"numpy_nullable\" is set, pyarrow is used for all dtypes if \"pyarrow\" is set."
msgstr ""

#: ../../source/user_guide/io.rst:179
msgid "The dtype_backends are still experimential."
msgstr ""

#: ../../source/user_guide/io.rst:190
msgid "engine : {``'c'``, ``'python'``, ``'pyarrow'``}"
msgstr ""

#: ../../source/user_guide/io.rst:-1
msgid "{"
msgstr ""

#: ../../source/user_guide/io.rst:184
msgid "Parser engine to use. The C and pyarrow engines are faster, while the python engine is currently more feature-complete. Multithreading is currently only supported by the pyarrow engine."
msgstr ""

#: ../../source/user_guide/io.rst:190
msgid "The \"pyarrow\" engine was added as an *experimental* engine, and some features are unsupported, or may not work correctly, with this engine."
msgstr ""

#: ../../source/user_guide/io.rst:193
msgid "converters : dict, default ``None``"
msgstr ""

#: ../../source/user_guide/io.rst:-1
msgid "dict, default"
msgstr ""

#: ../../source/user_guide/io.rst:193
msgid "Dict of functions for converting values in certain columns. Keys can either be integers or column labels."
msgstr ""

#: ../../source/user_guide/io.rst:195
msgid "true_values : list, default ``None``"
msgstr ""

#: ../../source/user_guide/io.rst:-1
msgid "list, default"
msgstr ""

#: ../../source/user_guide/io.rst:196
msgid "Values to consider as ``True``."
msgstr ""

#: ../../source/user_guide/io.rst:197
msgid "false_values : list, default ``None``"
msgstr ""

#: ../../source/user_guide/io.rst:198
msgid "Values to consider as ``False``."
msgstr ""

#: ../../source/user_guide/io.rst:199
msgid "skipinitialspace : boolean, default ``False``"
msgstr ""

#: ../../source/user_guide/io.rst:-1
msgid "boolean, default"
msgstr ""

#: ../../source/user_guide/io.rst:200
msgid "Skip spaces after delimiter."
msgstr ""

#: ../../source/user_guide/io.rst:212
msgid "skiprows : list-like or integer, default ``None``"
msgstr ""

#: ../../source/user_guide/io.rst:-1
msgid "list-like or integer, default"
msgstr ""

#: ../../source/user_guide/io.rst:202
msgid "Line numbers to skip (0-indexed) or number of lines to skip (int) at the start of the file."
msgstr ""

#: ../../source/user_guide/io.rst:205
msgid "If callable, the callable function will be evaluated against the row indices, returning True if the row should be skipped and False otherwise:"
msgstr ""

#: ../../source/user_guide/io.rst:215
msgid "skipfooter : int, default ``0``"
msgstr ""

#: ../../source/user_guide/io.rst:-1
msgid "int, default"
msgstr ""

#: ../../source/user_guide/io.rst:215
msgid "Number of lines at bottom of file to skip (unsupported with engine='c')."
msgstr ""

#: ../../source/user_guide/io.rst:217
msgid "nrows : int, default ``None``"
msgstr ""

#: ../../source/user_guide/io.rst:218
msgid "Number of rows of file to read. Useful for reading pieces of large files."
msgstr ""

#: ../../source/user_guide/io.rst:224
msgid "low_memory : boolean, default ``True``"
msgstr ""

#: ../../source/user_guide/io.rst:220
msgid "Internally process the file in chunks, resulting in lower memory use while parsing, but possibly mixed type inference.  To ensure no mixed types either set ``False``, or specify the type with the ``dtype`` parameter. Note that the entire file is read into a single ``DataFrame`` regardless, use the ``chunksize`` or ``iterator`` parameter to return the data in chunks. (Only valid with C parser)"
msgstr ""

#: ../../source/user_guide/io.rst:229
msgid "memory_map"
msgstr ""

#: ../../source/user_guide/io.rst:227
msgid "If a filepath is provided for ``filepath_or_buffer``, map the file object directly onto memory and access the data directly from there. Using this option can improve performance because there is no longer any I/O overhead."
msgstr ""

#: ../../source/user_guide/io.rst:232
msgid "NA and missing data handling"
msgstr ""

#: ../../source/user_guide/io.rst:237
msgid "na_values : scalar, str, list-like, or dict, default ``None``"
msgstr ""

#: ../../source/user_guide/io.rst:-1
msgid "scalar, str, list-like, or dict, default"
msgstr ""

#: ../../source/user_guide/io.rst:235
msgid "Additional strings to recognize as NA/NaN. If dict passed, specific per-column NA values. See :ref:`na values const <io.navaluesconst>` below for a list of the values interpreted as NaN by default."
msgstr ""

#: ../../source/user_guide/io.rst:252
msgid "keep_default_na : boolean, default ``True``"
msgstr ""

#: ../../source/user_guide/io.rst:240
msgid "Whether or not to include the default NaN values when parsing the data. Depending on whether ``na_values`` is passed in, the behavior is as follows:"
msgstr ""

#: ../../source/user_guide/io.rst:243
msgid "If ``keep_default_na`` is ``True``, and ``na_values`` are specified, ``na_values`` is appended to the default NaN values used for parsing."
msgstr ""

#: ../../source/user_guide/io.rst:245
msgid "If ``keep_default_na`` is ``True``, and ``na_values`` are not specified, only the default NaN values are used for parsing."
msgstr ""

#: ../../source/user_guide/io.rst:247
msgid "If ``keep_default_na`` is ``False``, and ``na_values`` are specified, only the NaN values specified ``na_values`` are used for parsing."
msgstr ""

#: ../../source/user_guide/io.rst:249
msgid "If ``keep_default_na`` is ``False``, and ``na_values`` are not specified, no strings will be parsed as NaN."
msgstr ""

#: ../../source/user_guide/io.rst:252
msgid "Note that if ``na_filter`` is passed in as ``False``, the ``keep_default_na`` and ``na_values`` parameters will be ignored."
msgstr ""

#: ../../source/user_guide/io.rst:256
msgid "na_filter : boolean, default ``True``"
msgstr ""

#: ../../source/user_guide/io.rst:255
msgid "Detect missing value markers (empty strings and the value of na_values). In data without any NAs, passing ``na_filter=False`` can improve the performance of reading a large file."
msgstr ""

#: ../../source/user_guide/io.rst:258
msgid "verbose : boolean, default ``False``"
msgstr ""

#: ../../source/user_guide/io.rst:259
msgid "Indicate number of NA values placed in non-numeric columns."
msgstr ""

#: ../../source/user_guide/io.rst:261
msgid "skip_blank_lines : boolean, default ``True``"
msgstr ""

#: ../../source/user_guide/io.rst:261
msgid "If ``True``, skip over blank lines rather than interpreting as NaN values."
msgstr ""

#: ../../source/user_guide/io.rst:266
msgid "Datetime handling"
msgstr ""

#: ../../source/user_guide/io.rst:276
msgid "parse_dates : boolean or list of ints or names or list of lists or dict, default ``False``."
msgstr ""

#: ../../source/user_guide/io.rst:-1
msgid "boolean or list of ints or names or list of lists or dict, default"
msgstr ""

#: ../../source/user_guide/io.rst:269
msgid "If ``True`` -> try parsing the index."
msgstr ""

#: ../../source/user_guide/io.rst:270
msgid "If ``[1, 2, 3]`` ->  try parsing columns 1, 2, 3 each as a separate date column."
msgstr ""

#: ../../source/user_guide/io.rst:272
msgid "If ``[[1, 3]]`` -> combine columns 1 and 3 and parse as a single date column."
msgstr ""

#: ../../source/user_guide/io.rst:274
msgid "If ``{'foo': [1, 3]}`` -> parse columns 1, 3 as date and call result 'foo'."
msgstr ""

#: ../../source/user_guide/io.rst:277
msgid "A fast-path exists for iso8601-formatted dates."
msgstr ""

#: ../../source/user_guide/io.rst:282
msgid "infer_datetime_format : boolean, default ``False``"
msgstr ""

#: ../../source/user_guide/io.rst:279
msgid "If ``True`` and parse_dates is enabled for a column, attempt to infer the datetime format to speed up the processing."
msgstr ""

#: ../../source/user_guide/io.rst:282
msgid "A strict version of this argument is now the default, passing it has no effect."
msgstr ""

#: ../../source/user_guide/io.rst:285
msgid "keep_date_col : boolean, default ``False``"
msgstr ""

#: ../../source/user_guide/io.rst:285
msgid "If ``True`` and parse_dates specifies combining multiple columns then keep the original columns."
msgstr ""

#: ../../source/user_guide/io.rst:298
msgid "date_parser : function, default ``None``"
msgstr ""

#: ../../source/user_guide/io.rst:-1
msgid "function, default"
msgstr ""

#: ../../source/user_guide/io.rst:288
msgid "Function to use for converting a sequence of string columns to an array of datetime instances. The default uses ``dateutil.parser.parser`` to do the conversion. pandas will try to call date_parser in three different ways, advancing to the next if an exception occurs: 1) Pass one or more arrays (as defined by parse_dates) as arguments; 2) concatenate (row-wise) the string values from the columns defined by parse_dates into a single array and pass that; and 3) call date_parser once for each row using one or more strings (corresponding to the columns defined by parse_dates) as arguments."
msgstr ""

#: ../../source/user_guide/io.rst:297
msgid "Use ``date_format`` instead, or read in as ``object`` and then apply :func:`to_datetime` as-needed."
msgstr ""

#: ../../source/user_guide/io.rst:304
msgid "date_format : str or dict of column -> format, default ``None``"
msgstr ""

#: ../../source/user_guide/io.rst:-1
msgid "str or dict of column -> format, default"
msgstr ""

#: ../../source/user_guide/io.rst:301
msgid "If used in conjunction with ``parse_dates``, will parse dates according to this format. For anything more complex, please read in as ``object`` and then apply :func:`to_datetime` as-needed."
msgstr ""

#: ../../source/user_guide/io.rst:306
msgid "dayfirst : boolean, default ``False``"
msgstr ""

#: ../../source/user_guide/io.rst:307
msgid "DD/MM format dates, international and European format."
msgstr ""

#: ../../source/user_guide/io.rst:311
msgid "cache_dates"
msgstr ""

#: ../../source/user_guide/io.rst:-1
msgid "boolean, default True"
msgstr ""

#: ../../source/user_guide/io.rst:309
msgid "If True, use a cache of unique, converted dates to apply the datetime conversion. May produce significant speed-up when parsing duplicate date strings, especially ones with timezone offsets."
msgstr ""

#: ../../source/user_guide/io.rst:314
msgid "Iteration"
msgstr ""

#: ../../source/user_guide/io.rst:317
msgid "iterator : boolean, default ``False``"
msgstr ""

#: ../../source/user_guide/io.rst:317
msgid "Return ``TextFileReader`` object for iteration or getting chunks with ``get_chunk()``."
msgstr ""

#: ../../source/user_guide/io.rst:321
msgid "chunksize : int, default ``None``"
msgstr ""

#: ../../source/user_guide/io.rst:320
msgid "Return ``TextFileReader`` object for iteration. See :ref:`iterating and chunking <io.chunking>` below."
msgstr ""

#: ../../source/user_guide/io.rst:324
msgid "Quoting, compression, and file format"
msgstr ""

#: ../../source/user_guide/io.rst:337
msgid "compression : {``'infer'``, ``'gzip'``, ``'bz2'``, ``'zip'``, ``'xz'``, ``'zstd'``, ``None``, ``dict``}, default ``'infer'``"
msgstr ""

#: ../../source/user_guide/io.rst:327
msgid "For on-the-fly decompression of on-disk data. If 'infer', then use gzip, bz2, zip, xz, or zstandard if ``filepath_or_buffer`` is path-like ending in '.gz', '.bz2', '.zip', '.xz', '.zst', respectively, and no decompression otherwise. If using 'zip', the ZIP file must contain only one data file to be read in. Set to ``None`` for no decompression. Can also be a dict with key ``'method'`` set to one of {``'zip'``, ``'gzip'``, ``'bz2'``, ``'zstd'``} and other key-value pairs are forwarded to ``zipfile.ZipFile``, ``gzip.GzipFile``, ``bz2.BZ2File``, or ``zstandard.ZstdDecompressor``. As an example, the following could be passed for faster compression and to create a reproducible gzip archive: ``compression={'method': 'gzip', 'compresslevel': 1, 'mtime': 1}``."
msgstr ""

#: ../../source/user_guide/io.rst:338
msgid "Previous versions forwarded dict entries for 'gzip' to ``gzip.open``."
msgstr ""

#: ../../source/user_guide/io.rst:339
msgid "thousands : str, default ``None``"
msgstr ""

#: ../../source/user_guide/io.rst:340
msgid "Thousands separator."
msgstr ""

#: ../../source/user_guide/io.rst:341
msgid "decimal : str, default ``'.'``"
msgstr ""

#: ../../source/user_guide/io.rst:342
msgid "Character to recognize as decimal point. E.g. use ``','`` for European data."
msgstr ""

#: ../../source/user_guide/io.rst:345
msgid "float_precision"
msgstr ""

#: ../../source/user_guide/io.rst:-1
msgid "string, default None"
msgstr ""

#: ../../source/user_guide/io.rst:344
msgid "Specifies which converter the C engine should use for floating-point values. The options are ``None`` for the ordinary converter, ``high`` for the high-precision converter, and ``round_trip`` for the round-trip converter."
msgstr ""

#: ../../source/user_guide/io.rst:347
msgid "lineterminator : str (length 1), default ``None``"
msgstr ""

#: ../../source/user_guide/io.rst:-1
msgid "str (length 1), default"
msgstr ""

#: ../../source/user_guide/io.rst:348
msgid "Character to break file into lines. Only valid with C parser."
msgstr ""

#: ../../source/user_guide/io.rst:350
msgid "quotechar"
msgstr ""

#: ../../source/user_guide/io.rst:-1
msgid "str (length 1)"
msgstr ""

#: ../../source/user_guide/io.rst:350
msgid "The character used to denote the start and end of a quoted item. Quoted items can include the delimiter and it will be ignored."
msgstr ""

#: ../../source/user_guide/io.rst:354
msgid "quoting : int or ``csv.QUOTE_*`` instance, default ``0``"
msgstr ""

#: ../../source/user_guide/io.rst:-1
msgid "int or"
msgstr ""

#: ../../source/user_guide/io.rst:353
msgid "Control field quoting behavior per ``csv.QUOTE_*`` constants. Use one of ``QUOTE_MINIMAL`` (0), ``QUOTE_ALL`` (1), ``QUOTE_NONNUMERIC`` (2) or ``QUOTE_NONE`` (3)."
msgstr ""

#: ../../source/user_guide/io.rst:358
msgid "doublequote : boolean, default ``True``"
msgstr ""

#: ../../source/user_guide/io.rst:357
msgid "When ``quotechar`` is specified and ``quoting`` is not ``QUOTE_NONE``, indicate whether or not to interpret two consecutive ``quotechar`` elements **inside** a field as a single ``quotechar`` element."
msgstr ""

#: ../../source/user_guide/io.rst:360
msgid "escapechar : str (length 1), default ``None``"
msgstr ""

#: ../../source/user_guide/io.rst:361
msgid "One-character string used to escape delimiter when quoting is ``QUOTE_NONE``."
msgstr ""

#: ../../source/user_guide/io.rst:367
msgid "comment : str, default ``None``"
msgstr ""

#: ../../source/user_guide/io.rst:363
msgid "Indicates remainder of line should not be parsed. If found at the beginning of a line, the line will be ignored altogether. This parameter must be a single character. Like empty lines (as long as ``skip_blank_lines=True``), fully commented lines are ignored by the parameter ``header`` but not by ``skiprows``. For example, if ``comment='#'``, parsing '#empty\\\\na,b,c\\\\n1,2,3' with ``header=0`` will result in 'a,b,c' being treated as the header."
msgstr ""

#: ../../source/user_guide/io.rst:371
msgid "encoding : str, default ``None``"
msgstr ""

#: ../../source/user_guide/io.rst:370
msgid "Encoding to use for UTF when reading/writing (e.g. ``'utf-8'``). `List of Python standard encodings <https://docs.python.org/3/library/codecs.html#standard-encodings>`_."
msgstr ""

#: ../../source/user_guide/io.rst:378
msgid "dialect : str or :class:`python:csv.Dialect` instance, default ``None``"
msgstr ""

#: ../../source/user_guide/io.rst:-1
msgid "str or"
msgstr ""

#: ../../source/user_guide/io.rst:374
msgid "If provided, this parameter will override values (default or not) for the following parameters: ``delimiter``, ``doublequote``, ``escapechar``, ``skipinitialspace``, ``quotechar``, and ``quoting``. If it is necessary to override values, a ParserWarning will be issued. See :class:`python:csv.Dialect` documentation for more details."
msgstr ""

#: ../../source/user_guide/io.rst:381
msgid "Error handling"
msgstr ""

#: ../../source/user_guide/io.rst:391
msgid "on_bad_lines"
msgstr ""

#: ../../source/user_guide/io.rst:-1
msgid "{{'error', 'warn', 'skip'}}, default 'error'"
msgstr ""

#: ../../source/user_guide/io.rst:384
msgid "Specifies what to do upon encountering a bad line (a line with too many fields). Allowed values are :"
msgstr ""

#: ../../source/user_guide/io.rst:387
msgid "'error', raise an ParserError when a bad line is encountered."
msgstr ""

#: ../../source/user_guide/io.rst:388
msgid "'warn', print a warning when a bad line is encountered and skip that line."
msgstr ""

#: ../../source/user_guide/io.rst:389
msgid "'skip', skip bad lines without raising or warning when they are encountered."
msgstr ""

#: ../../source/user_guide/io.rst:396
msgid "Specifying column data types"
msgstr ""

#: ../../source/user_guide/io.rst:398
msgid "You can indicate the data type for the whole ``DataFrame`` or individual columns:"
msgstr ""

#: ../../source/user_guide/io.rst:414
msgid "Fortunately, pandas offers more than one way to ensure that your column(s) contain only one ``dtype``. If you're unfamiliar with these concepts, you can see :ref:`here<basics.dtypes>` to learn more about dtypes, and :ref:`here<basics.object_conversion>` to learn more about ``object`` conversion in pandas."
msgstr ""

#: ../../source/user_guide/io.rst:421
msgid "For instance, you can use the ``converters`` argument of :func:`~pandas.read_csv`:"
msgstr ""

#: ../../source/user_guide/io.rst:431
msgid "Or you can use the :func:`~pandas.to_numeric` function to coerce the dtypes after reading in the data,"
msgstr ""

#: ../../source/user_guide/io.rst:441
msgid "which will convert all valid parsing to floats, leaving the invalid parsing as ``NaN``."
msgstr ""

#: ../../source/user_guide/io.rst:444
msgid "Ultimately, how you deal with reading in columns containing mixed dtypes depends on your specific needs. In the case above, if you wanted to ``NaN`` out the data anomalies, then :func:`~pandas.to_numeric` is probably your best option. However, if you wanted for all the data to be coerced, no matter the type, then using the ``converters`` argument of :func:`~pandas.read_csv` would certainly be worth trying."
msgstr ""

#: ../../source/user_guide/io.rst:452
msgid "In some cases, reading in abnormal data with columns containing mixed dtypes will result in an inconsistent dataset. If you rely on pandas to infer the dtypes of your columns, the parsing engine will go and infer the dtypes for different chunks of the data, rather than the whole dataset at once. Consequently, you can end up with column(s) with mixed dtypes. For example,"
msgstr ""

#: ../../source/user_guide/io.rst:468
msgid "will result with ``mixed_df`` containing an ``int`` dtype for certain chunks of the column, and ``str`` for others due to the mixed dtypes from the data that was read in. It is important to note that the overall column will be marked with a ``dtype`` of ``object``, which is used for columns with mixed dtypes."
msgstr ""

#: ../../source/user_guide/io.rst:480
msgid "Setting ``dtype_backend=\"numpy_nullable\"`` will result in nullable dtypes for every column."
msgstr ""

#: ../../source/user_guide/io.rst:496
msgid "Specifying categorical dtype"
msgstr ""

#: ../../source/user_guide/io.rst:498
msgid "``Categorical`` columns can be parsed directly by specifying ``dtype='category'`` or ``dtype=CategoricalDtype(categories, ordered)``."
msgstr ""

#: ../../source/user_guide/io.rst:509
msgid "Individual columns can be parsed as a ``Categorical`` using a dict specification:"
msgstr ""

#: ../../source/user_guide/io.rst:516
msgid "Specifying ``dtype='category'`` will result in an unordered ``Categorical`` whose ``categories`` are the unique values observed in the data. For more control on the categories and order, create a :class:`~pandas.api.types.CategoricalDtype` ahead of time, and pass that for that column's ``dtype``."
msgstr ""

#: ../../source/user_guide/io.rst:529
msgid "When using ``dtype=CategoricalDtype``, \"unexpected\" values outside of ``dtype.categories`` are treated as missing values."
msgstr ""

#: ../../source/user_guide/io.rst:537
msgid "This matches the behavior of :meth:`Categorical.set_categories`."
msgstr ""

#: ../../source/user_guide/io.rst:541
msgid "With ``dtype='category'``, the resulting categories will always be parsed as strings (object dtype). If the categories are numeric they can be converted using the :func:`to_numeric` function, or as appropriate, another converter such as :func:`to_datetime`."
msgstr ""

#: ../../source/user_guide/io.rst:546
msgid "When ``dtype`` is a ``CategoricalDtype`` with homogeneous ``categories`` ( all numeric, all datetimes, etc.), the conversion is done automatically."
msgstr ""

#: ../../source/user_guide/io.rst:560
msgid "Naming and using columns"
msgstr ""

#: ../../source/user_guide/io.rst:565
msgid "Handling column names"
msgstr ""

#: ../../source/user_guide/io.rst:567
msgid "A file may or may not have a header row. pandas assumes the first row should be used as the column names:"
msgstr ""

#: ../../source/user_guide/io.rst:576
msgid "By specifying the ``names`` argument in conjunction with ``header`` you can indicate other names to use and whether or not to throw away the header row (if any):"
msgstr ""

#: ../../source/user_guide/io.rst:586
msgid "If the header is in a row other than the first, pass the row number to ``header``. This will skip the preceding rows:"
msgstr ""

#: ../../source/user_guide/io.rst:596
msgid "Default behavior is to infer the column names: if no names are passed the behavior is identical to ``header=0`` and column names are inferred from the first non-blank line of the file, if column names are passed explicitly then the behavior is identical to ``header=None``."
msgstr ""

#: ../../source/user_guide/io.rst:605
msgid "Duplicate names parsing"
msgstr ""

#: ../../source/user_guide/io.rst:607
msgid "If the file or header contains duplicate names, pandas will by default distinguish between them so as to prevent overwriting data:"
msgstr ""

#: ../../source/user_guide/io.rst:615
msgid "There is no more duplicate data because duplicate columns 'X', ..., 'X' become 'X', 'X.1', ..., 'X.N'."
msgstr ""

#: ../../source/user_guide/io.rst:621
msgid "Filtering columns (``usecols``)"
msgstr ""

#: ../../source/user_guide/io.rst:623
msgid "The ``usecols`` argument allows you to select any subset of the columns in a file, either using the column names, position numbers or a callable:"
msgstr ""

#: ../../source/user_guide/io.rst:634
msgid "The ``usecols`` argument can also be used to specify which columns not to use in the final result:"
msgstr ""

#: ../../source/user_guide/io.rst:641
msgid "In this case, the callable is specifying that we exclude the \"a\" and \"c\" columns from the output."
msgstr ""

#: ../../source/user_guide/io.rst:645
msgid "Comments and empty lines"
msgstr ""

#: ../../source/user_guide/io.rst:650
msgid "Ignoring line comments and empty lines"
msgstr ""

#: ../../source/user_guide/io.rst:652
msgid "If the ``comment`` parameter is specified, then completely commented lines will be ignored. By default, completely blank lines will be ignored as well."
msgstr ""

#: ../../source/user_guide/io.rst:661
msgid "If ``skip_blank_lines=False``, then ``read_csv`` will not ignore blank lines:"
msgstr ""

#: ../../source/user_guide/io.rst:670
msgid "The presence of ignored lines might create ambiguities involving line numbers; the parameter ``header`` uses row numbers (ignoring commented/empty lines), while ``skiprows`` uses line numbers (including commented/empty lines):"
msgstr ""

#: ../../source/user_guide/io.rst:681
msgid "If both ``header`` and ``skiprows`` are specified, ``header`` will be relative to the end of ``skiprows``. For example:"
msgstr ""

#: ../../source/user_guide/io.rst:702
msgid "Comments"
msgstr ""

#: ../../source/user_guide/io.rst:704
msgid "Sometimes comments or meta data may be included in a file:"
msgstr ""

#: ../../source/user_guide/io.rst:719
msgid "By default, the parser includes the comments in the output:"
msgstr ""

#: ../../source/user_guide/io.rst:726
msgid "We can suppress the comments using the ``comment`` keyword:"
msgstr ""

#: ../../source/user_guide/io.rst:741
msgid "Dealing with Unicode data"
msgstr ""

#: ../../source/user_guide/io.rst:743
msgid "The ``encoding`` argument should be used for encoded unicode data, which will result in byte strings being decoded to unicode in the result:"
msgstr ""

#: ../../source/user_guide/io.rst:756
msgid "Some formats which encode all characters as multiple bytes, like UTF-16, won't parse correctly at all without specifying the encoding. `Full list of Python standard encodings <https://docs.python.org/3/library/codecs.html#standard-encodings>`_."
msgstr ""

#: ../../source/user_guide/io.rst:764
msgid "Index columns and trailing delimiters"
msgstr ""

#: ../../source/user_guide/io.rst:766
msgid "If a file has one more column of data than the number of column names, the first column will be used as the ``DataFrame``'s row names:"
msgstr ""

#: ../../source/user_guide/io.rst:779
msgid "Ordinarily, you can achieve this behavior using the ``index_col`` option."
msgstr ""

#: ../../source/user_guide/io.rst:781
msgid "There are some exception cases when a file has been prepared with delimiters at the end of each data line, confusing the parser. To explicitly disable the index column inference and discard the last column, pass ``index_col=False``:"
msgstr ""

#: ../../source/user_guide/io.rst:792
msgid "If a subset of data is being parsed using the ``usecols`` option, the ``index_col`` specification is based on that subset, not the original data."
msgstr ""

#: ../../source/user_guide/io.rst:805
msgid "Date Handling"
msgstr ""

#: ../../source/user_guide/io.rst:808
msgid "Specifying date columns"
msgstr ""

#: ../../source/user_guide/io.rst:810
msgid "To better facilitate working with datetime data, :func:`read_csv` uses the keyword arguments ``parse_dates`` and ``date_format`` to allow users to specify a variety of columns and date/time formats to turn the input text data into ``datetime`` objects."
msgstr ""

#: ../../source/user_guide/io.rst:815
msgid "The simplest case is to just pass in ``parse_dates=True``:"
msgstr ""

#: ../../source/user_guide/io.rst:829
msgid "It is often the case that we may want to store date and time data separately, or store various date fields separately. the ``parse_dates`` keyword can be used to specify a combination of columns to parse the dates and/or times from."
msgstr ""

#: ../../source/user_guide/io.rst:833
msgid "You can specify a list of column lists to ``parse_dates``, the resulting date columns will be prepended to the output (so as to not affect the existing column order) and the new column names will be the concatenation of the component column names:"
msgstr ""

#: ../../source/user_guide/io.rst:855
msgid "By default the parser removes the component date columns, but you can choose to retain them via the ``keep_date_col`` keyword:"
msgstr ""

#: ../../source/user_guide/io.rst:865
msgid "Note that if you wish to combine multiple columns into a single date column, a nested list must be used. In other words, ``parse_dates=[1, 2]`` indicates that the second and third columns should each be parsed as separate date columns while ``parse_dates=[[1, 2]]`` means the two columns should be parsed into a single column."
msgstr ""

#: ../../source/user_guide/io.rst:871
msgid "You can also use a dict to specify custom name columns:"
msgstr ""

#: ../../source/user_guide/io.rst:879
msgid "It is important to remember that if multiple text columns are to be parsed into a single date column, then a new column is prepended to the data. The ``index_col`` specification is based off of this new set of columns rather than the original data columns:"
msgstr ""

#: ../../source/user_guide/io.rst:894
msgid "If a column or index contains an unparsable date, the entire column or index will be returned unaltered as an object data type. For non-standard datetime parsing, use :func:`to_datetime` after ``pd.read_csv``."
msgstr ""

#: ../../source/user_guide/io.rst:900
msgid "read_csv has a fast_path for parsing datetime strings in iso8601 format, e.g \"2000-01-01T00:01:02+00:00\" and similar variations. If you can arrange for your data to store datetimes in this format, load times will be significantly faster, ~20x has been observed."
msgstr ""

#: ../../source/user_guide/io.rst:907
msgid "Date parsing functions"
msgstr ""

#: ../../source/user_guide/io.rst:909
msgid "Finally, the parser allows you to specify a custom ``date_format``. Performance-wise, you should try these methods of parsing dates in order:"
msgstr ""

#: ../../source/user_guide/io.rst:912
msgid "If you know the format, use ``date_format``, e.g.: ``date_format=\"%d/%m/%Y\"`` or ``date_format={column_name: \"%d/%m/%Y\"}``."
msgstr ""

#: ../../source/user_guide/io.rst:915
msgid "If you different formats for different columns, or want to pass any extra options (such as ``utc``) to ``to_datetime``, then you should read in your data as ``object`` dtype, and then use ``to_datetime``."
msgstr ""

#: ../../source/user_guide/io.rst:929
msgid "Parsing a CSV with mixed timezones"
msgstr ""

#: ../../source/user_guide/io.rst:931
msgid "pandas cannot natively represent a column or index with mixed timezones. If your CSV file contains columns with a mixture of timezones, the default result will be an object-dtype column with strings, even with ``parse_dates``. To parse the mixed-timezone values as a datetime column, read in as ``object`` dtype and then call :func:`to_datetime` with ``utc=True``."
msgstr ""

#: ../../source/user_guide/io.rst:953
msgid "Inferring datetime format"
msgstr ""

#: ../../source/user_guide/io.rst:955
msgid "Here are some examples of datetime strings that can be guessed (all representing December 30th, 2011 at 00:00:00):"
msgstr ""

#: ../../source/user_guide/io.rst:958
msgid "\"20111230\""
msgstr ""

#: ../../source/user_guide/io.rst:959
msgid "\"2011/12/30\""
msgstr ""

#: ../../source/user_guide/io.rst:960
msgid "\"20111230 00:00:00\""
msgstr ""

#: ../../source/user_guide/io.rst:961
msgid "\"12/30/2011 00:00:00\""
msgstr ""

#: ../../source/user_guide/io.rst:962
msgid "\"30/Dec/2011 00:00:00\""
msgstr ""

#: ../../source/user_guide/io.rst:963
msgid "\"30/December/2011 00:00:00\""
msgstr ""

#: ../../source/user_guide/io.rst:965
msgid "Note that format inference is sensitive to ``dayfirst``.  With ``dayfirst=True``, it will guess \"01/12/2011\" to be December 1st. With ``dayfirst=False`` (default) it will guess \"01/12/2011\" to be January 12th."
msgstr ""

#: ../../source/user_guide/io.rst:969
msgid "If you try to parse a column of date strings, pandas will attempt to guess the format from the first non-NaN element, and will then parse the rest of the column with that format. If pandas fails to guess the format (for example if your first string is ``'01 December US/Pacific 2000'``), then a warning will be raised and each row will be parsed individually by ``dateutil.parser.parse``. The safest way to parse dates is to explicitly set ``format=``."
msgstr ""

#: ../../source/user_guide/io.rst:985
msgid "In the case that you have mixed datetime formats within the same column, you can pass  ``format='mixed'``"
msgstr ""

#: ../../source/user_guide/io.rst:995
msgid "or, if your datetime formats are all ISO8601 (possibly not identically-formatted):"
msgstr ""

#: ../../source/user_guide/io.rst:1010
msgid "International date formats"
msgstr ""

#: ../../source/user_guide/io.rst:1012
msgid "While US date formats tend to be MM/DD/YYYY, many international formats use DD/MM/YYYY instead. For convenience, a ``dayfirst`` keyword is provided:"
msgstr ""

#: ../../source/user_guide/io.rst:1031
msgid "Writing CSVs to binary file objects"
msgstr ""

#: ../../source/user_guide/io.rst:1035
msgid "``df.to_csv(..., mode=\"wb\")`` allows writing a CSV to a file object opened binary mode. In most cases, it is not necessary to specify ``mode`` as Pandas will auto-detect whether the file object is opened in text or binary mode."
msgstr ""

#: ../../source/user_guide/io.rst:1051
msgid "Specifying method for floating-point conversion"
msgstr ""

#: ../../source/user_guide/io.rst:1053
msgid "The parameter ``float_precision`` can be specified in order to use a specific floating-point converter during parsing with the C engine. The options are the ordinary converter, the high-precision converter, and the round-trip converter (which is guaranteed to round-trip values after writing to a file). For example:"
msgstr ""

#: ../../source/user_guide/io.rst:1086
msgid "Thousand separators"
msgstr ""

#: ../../source/user_guide/io.rst:1088
msgid "For large numbers that have been written with a thousands separator, you can set the ``thousands`` keyword to a string of length 1 so that integers will be parsed correctly:"
msgstr ""

#: ../../source/user_guide/io.rst:1092
msgid "By default, numbers with a thousands separator will be parsed as strings:"
msgstr ""

#: ../../source/user_guide/io.rst:1111
msgid "The ``thousands`` keyword allows integers to be parsed correctly:"
msgstr ""

#: ../../source/user_guide/io.rst:1128
msgid "NA values"
msgstr ""

#: ../../source/user_guide/io.rst:1130
msgid "To control which values are parsed as missing values (which are signified by ``NaN``), specify a string in ``na_values``. If you specify a list of strings, then all values in it are considered to be missing values. If you specify a number (a ``float``, like ``5.0`` or an ``integer`` like ``5``), the corresponding equivalent values will also imply a missing value (in this case effectively ``[5.0, 5]`` are recognized as ``NaN``)."
msgstr ""

#: ../../source/user_guide/io.rst:1137
msgid "To completely override the default values that are recognized as missing, specify ``keep_default_na=False``."
msgstr ""

#: ../../source/user_guide/io.rst:1141
msgid "The default ``NaN`` recognized values are ``['-1.#IND', '1.#QNAN', '1.#IND', '-1.#QNAN', '#N/A N/A', '#N/A', 'N/A', 'n/a', 'NA', '<NA>', '#NA', 'NULL', 'null', 'NaN', '-NaN', 'nan', '-nan', 'None', '']``."
msgstr ""

#: ../../source/user_guide/io.rst:1144
msgid "Let us consider some examples:"
msgstr ""

#: ../../source/user_guide/io.rst:1150
msgid "In the example above ``5`` and ``5.0`` will be recognized as ``NaN``, in addition to the defaults. A string will first be interpreted as a numerical ``5``, then as a ``NaN``."
msgstr ""

#: ../../source/user_guide/io.rst:1158
msgid "Above, only an empty field will be recognized as ``NaN``."
msgstr ""

#: ../../source/user_guide/io.rst:1164
msgid "Above, both ``NA`` and ``0`` as strings are ``NaN``."
msgstr ""

#: ../../source/user_guide/io.rst:1170
msgid "The default values, in addition to the string ``\"Nope\"`` are recognized as ``NaN``."
msgstr ""

#: ../../source/user_guide/io.rst:1176
msgid "Infinity"
msgstr ""

#: ../../source/user_guide/io.rst:1178
msgid "``inf`` like values will be parsed as ``np.inf`` (positive infinity), and ``-inf`` as ``-np.inf`` (negative infinity). These will ignore the case of the value, meaning ``Inf``, will also be parsed as ``np.inf``."
msgstr ""

#: ../../source/user_guide/io.rst:1184
msgid "Boolean values"
msgstr ""

#: ../../source/user_guide/io.rst:1186
msgid "The common values ``True``, ``False``, ``TRUE``, and ``FALSE`` are all recognized as boolean. Occasionally you might want to recognize other values as being boolean. To do this, use the ``true_values`` and ``false_values`` options as follows:"
msgstr ""

#: ../../source/user_guide/io.rst:1201
msgid "Handling \"bad\" lines"
msgstr ""

#: ../../source/user_guide/io.rst:1203
msgid "Some files may have malformed lines with too few fields or too many. Lines with too few fields will have NA values filled in the trailing fields. Lines with too many fields will raise an error by default:"
msgstr ""

#: ../../source/user_guide/io.rst:1213
msgid "You can elect to skip bad lines:"
msgstr ""

#: ../../source/user_guide/io.rst:1222
msgid "Or pass a callable function to handle the bad line if ``engine=\"python\"``. The bad line will be a list of strings that was split by the ``sep``:"
msgstr ""

#: ../../source/user_guide/io.rst:1236
msgid "The callable function will handle only a line with too many fields. Bad lines caused by other errors will be silently skipped."
msgstr ""

#: ../../source/user_guide/io.rst:1247
msgid "The line was not processed in this case, as a \"bad line\" here is caused by an escape character."
msgstr ""

#: ../../source/user_guide/io.rst:1249
msgid "You can also use the ``usecols`` parameter to eliminate extraneous column data that appear in some lines but not others:"
msgstr ""

#: ../../source/user_guide/io.rst:1257
msgid "In case you want to keep all data including the lines with too many fields, you can specify a sufficient number of ``names``. This ensures that lines with not enough fields are filled with ``NaN``."
msgstr ""

#: ../../source/user_guide/io.rst:1268
msgid "Dialect"
msgstr ""

#: ../../source/user_guide/io.rst:1270
msgid "The ``dialect`` keyword gives greater flexibility in specifying the file format. By default it uses the Excel dialect but you can specify either the dialect name or a :class:`python:csv.Dialect` instance."
msgstr ""

#: ../../source/user_guide/io.rst:1274
msgid "Suppose you had data with unenclosed quotes:"
msgstr ""

#: ../../source/user_guide/io.rst:1281
msgid "By default, ``read_csv`` uses the Excel dialect and treats the double quote as the quote character, which causes it to fail when it finds a newline before it finds the closing double quote."
msgstr ""

#: ../../source/user_guide/io.rst:1285
msgid "We can get around this using ``dialect``:"
msgstr ""

#: ../../source/user_guide/io.rst:1296
msgid "All of the dialect options can be specified separately by keyword arguments:"
msgstr ""

#: ../../source/user_guide/io.rst:1303
msgid "Another common dialect option is ``skipinitialspace``, to skip any whitespace after a delimiter:"
msgstr ""

#: ../../source/user_guide/io.rst:1312
msgid "The parsers make every attempt to \"do the right thing\" and not be fragile. Type inference is a pretty big deal. If a column can be coerced to integer dtype without altering the contents, the parser will do so. Any non-numeric columns will come through as object dtype as with the rest of pandas objects."
msgstr ""

#: ../../source/user_guide/io.rst:1320
msgid "Quoting and Escape Characters"
msgstr ""

#: ../../source/user_guide/io.rst:1322
msgid "Quotes (and other escape characters) in embedded fields can be handled in any number of ways. One way is to use backslashes; to properly parse this data, you should pass the ``escapechar`` option:"
msgstr ""

#: ../../source/user_guide/io.rst:1336
msgid "Files with fixed width columns"
msgstr ""

#: ../../source/user_guide/io.rst:1338
msgid "While :func:`read_csv` reads delimited data, the :func:`read_fwf` function works with data files that have known and fixed column widths. The function parameters to ``read_fwf`` are largely the same as ``read_csv`` with two extra parameters, and a different usage of the ``delimiter`` parameter:"
msgstr ""

#: ../../source/user_guide/io.rst:1343
msgid "``colspecs``: A list of pairs (tuples) giving the extents of the fixed-width fields of each line as half-open intervals (i.e.,  [from, to[ ). String value 'infer' can be used to instruct the parser to try detecting the column specifications from the first 100 rows of the data. Default behavior, if not specified, is to infer."
msgstr ""

#: ../../source/user_guide/io.rst:1348
msgid "``widths``: A list of field widths which can be used instead of 'colspecs' if the intervals are contiguous."
msgstr ""

#: ../../source/user_guide/io.rst:1350
msgid "``delimiter``: Characters to consider as filler characters in the fixed-width file. Can be used to specify the filler character of the fields if it is not spaces (e.g., '~')."
msgstr ""

#: ../../source/user_guide/io.rst:1354
msgid "Consider a typical fixed-width data file:"
msgstr ""

#: ../../source/user_guide/io.rst:1368
msgid "In order to parse this file into a ``DataFrame``, we simply need to supply the column specifications to the ``read_fwf`` function along with the file name:"
msgstr ""

#: ../../source/user_guide/io.rst:1378
msgid "Note how the parser automatically picks column names X.<column number> when ``header=None`` argument is specified. Alternatively, you can supply just the column widths for contiguous columns:"
msgstr ""

#: ../../source/user_guide/io.rst:1389
msgid "The parser will take care of extra white spaces around the columns so it's ok to have extra separation between the columns in the file."
msgstr ""

#: ../../source/user_guide/io.rst:1392
msgid "By default, ``read_fwf`` will try to infer the file's ``colspecs`` by using the first 100 rows of the file. It can do it only in cases when the columns are aligned and correctly separated by the provided ``delimiter`` (default delimiter is whitespace)."
msgstr ""

#: ../../source/user_guide/io.rst:1402
msgid "``read_fwf`` supports the ``dtype`` parameter for specifying the types of parsed columns to be different from the inferred type."
msgstr ""

#: ../../source/user_guide/io.rst:1417
msgid "Indexes"
msgstr ""

#: ../../source/user_guide/io.rst:1420
msgid "Files with an \"implicit\" index column"
msgstr ""

#: ../../source/user_guide/io.rst:1422
msgid "Consider a file with one less entry in the header than the number of data column:"
msgstr ""

#: ../../source/user_guide/io.rst:1432
msgid "In this special case, ``read_csv`` assumes that the first column is to be used as the index of the ``DataFrame``:"
msgstr ""

#: ../../source/user_guide/io.rst:1439
msgid "Note that the dates weren't automatically parsed. In that case you would need to do as before:"
msgstr ""

#: ../../source/user_guide/io.rst:1454
msgid "Reading an index with a ``MultiIndex``"
msgstr ""

#: ../../source/user_guide/io.rst:1458
msgid "Suppose you have data indexed by two columns:"
msgstr ""

#: ../../source/user_guide/io.rst:1467
msgid "The ``index_col`` argument to ``read_csv`` can take a list of column numbers to turn multiple columns into a ``MultiIndex`` for the index of the returned object:"
msgstr ""

#: ../../source/user_guide/io.rst:1485
msgid "Reading columns with a ``MultiIndex``"
msgstr ""

#: ../../source/user_guide/io.rst:1487
msgid "By specifying list of row locations for the ``header`` argument, you can read in a ``MultiIndex`` for the columns. Specifying non-consecutive rows will skip the intervening rows."
msgstr ""

#: ../../source/user_guide/io.rst:1500
msgid "``read_csv`` is also able to interpret a more common format of multi-columns indices."
msgstr ""

#: ../../source/user_guide/io.rst:1513
msgid "If an ``index_col`` is not specified (e.g. you don't have an index, or wrote it with ``df.to_csv(..., index=False)``, then any ``names`` on the columns index will be *lost*."
msgstr ""

#: ../../source/user_guide/io.rst:1526
msgid "Automatically \"sniffing\" the delimiter"
msgstr ""

#: ../../source/user_guide/io.rst:1528
msgid "``read_csv`` is capable of inferring delimited (not necessarily comma-separated) files, as pandas uses the :class:`python:csv.Sniffer` class of the csv module. For this, you have to specify ``sep=None``."
msgstr ""

#: ../../source/user_guide/io.rst:1546
msgid "Reading multiple files to create a single DataFrame"
msgstr ""

#: ../../source/user_guide/io.rst:1548
msgid "It's best to use :func:`~pandas.concat` to combine multiple files. See the :ref:`cookbook<cookbook.csv.multiple_files>` for an example."
msgstr ""

#: ../../source/user_guide/io.rst:1554
msgid "Iterating through files chunk by chunk"
msgstr ""

#: ../../source/user_guide/io.rst:1556
msgid "Suppose you wish to iterate through a (potentially very large) file lazily rather than reading the entire file into memory, such as the following:"
msgstr ""

#: ../../source/user_guide/io.rst:1568
msgid "By specifying a ``chunksize`` to ``read_csv``, the return value will be an iterable object of type ``TextFileReader``:"
msgstr ""

#: ../../source/user_guide/io.rst:1580
msgid "``read_csv/json/sas`` return a context-manager when iterating through a file."
msgstr ""

#: ../../source/user_guide/io.rst:1582
msgid "Specifying ``iterator=True`` will also return the ``TextFileReader`` object:"
msgstr ""

#: ../../source/user_guide/io.rst:1595
msgid "Specifying the parser engine"
msgstr ""

#: ../../source/user_guide/io.rst:1597
msgid "Pandas currently supports three engines, the C engine, the python engine, and an experimental pyarrow engine (requires the ``pyarrow`` package). In general, the pyarrow engine is fastest on larger workloads and is equivalent in speed to the C engine on most other workloads. The python engine tends to be slower than the pyarrow and C engines on most workloads. However, the pyarrow engine is much less robust than the C engine, which lacks a few features compared to the Python engine."
msgstr ""

#: ../../source/user_guide/io.rst:1604
msgid "Where possible, pandas uses the C parser (specified as ``engine='c'``), but it may fall back to Python if C-unsupported options are specified."
msgstr ""

#: ../../source/user_guide/io.rst:1607
msgid "Currently, options unsupported by the C and pyarrow engines include:"
msgstr ""

#: ../../source/user_guide/io.rst:1609
msgid "``sep`` other than a single character (e.g. regex separators)"
msgstr ""

#: ../../source/user_guide/io.rst:1610
msgid "``skipfooter``"
msgstr ""

#: ../../source/user_guide/io.rst:1611
msgid "``sep=None`` with ``delim_whitespace=False``"
msgstr ""

#: ../../source/user_guide/io.rst:1613
msgid "Specifying any of the above options will produce a ``ParserWarning`` unless the python engine is selected explicitly using ``engine='python'``."
msgstr ""

#: ../../source/user_guide/io.rst:1616
msgid "Options that are unsupported by the pyarrow engine which are not covered by the list above include:"
msgstr ""

#: ../../source/user_guide/io.rst:1618
msgid "``float_precision``"
msgstr ""

#: ../../source/user_guide/io.rst:1619
msgid "``chunksize``"
msgstr ""

#: ../../source/user_guide/io.rst:1620
msgid "``comment``"
msgstr ""

#: ../../source/user_guide/io.rst:1621
msgid "``nrows``"
msgstr ""

#: ../../source/user_guide/io.rst:1622
msgid "``thousands``"
msgstr ""

#: ../../source/user_guide/io.rst:1623
msgid "``memory_map``"
msgstr ""

#: ../../source/user_guide/io.rst:1624
msgid "``dialect``"
msgstr ""

#: ../../source/user_guide/io.rst:1625
msgid "``on_bad_lines``"
msgstr ""

#: ../../source/user_guide/io.rst:1626
msgid "``delim_whitespace``"
msgstr ""

#: ../../source/user_guide/io.rst:1627
msgid "``quoting``"
msgstr ""

#: ../../source/user_guide/io.rst:1628
msgid "``lineterminator``"
msgstr ""

#: ../../source/user_guide/io.rst:1629
msgid "``converters``"
msgstr ""

#: ../../source/user_guide/io.rst:1630
msgid "``decimal``"
msgstr ""

#: ../../source/user_guide/io.rst:1631
msgid "``iterator``"
msgstr ""

#: ../../source/user_guide/io.rst:1632
msgid "``dayfirst``"
msgstr ""

#: ../../source/user_guide/io.rst:1633
msgid "``infer_datetime_format``"
msgstr ""

#: ../../source/user_guide/io.rst:1634
msgid "``verbose``"
msgstr ""

#: ../../source/user_guide/io.rst:1635
msgid "``skipinitialspace``"
msgstr ""

#: ../../source/user_guide/io.rst:1636
msgid "``low_memory``"
msgstr ""

#: ../../source/user_guide/io.rst:1638
msgid "Specifying these options with ``engine='pyarrow'`` will raise a ``ValueError``."
msgstr ""

#: ../../source/user_guide/io.rst:1643
msgid "Reading/writing remote files"
msgstr ""

#: ../../source/user_guide/io.rst:1645
msgid "You can pass in a URL to read or write remote files to many of pandas' IO functions - the following example shows reading a CSV file:"
msgstr ""

#: ../../source/user_guide/io.rst:1654
msgid "A custom header can be sent alongside HTTP(s) requests by passing a dictionary of header key value mappings to the ``storage_options`` keyword argument as shown below:"
msgstr ""

#: ../../source/user_guide/io.rst:1666
msgid "All URLs which are not local files or HTTP(s) are handled by `fsspec`_, if installed, and its various filesystem implementations (including Amazon S3, Google Cloud, SSH, FTP, webHDFS...). Some of these implementations will require additional packages to be installed, for example S3 URLs require the `s3fs <https://pypi.org/project/s3fs/>`_ library:"
msgstr ""

#: ../../source/user_guide/io.rst:1678
msgid "When dealing with remote storage systems, you might need extra configuration with environment variables or config files in special locations. For example, to access data in your S3 bucket, you will need to define credentials in one of the several ways listed in the `S3Fs documentation <https://s3fs.readthedocs.io/en/latest/#credentials>`_. The same is true for several of the storage backends, and you should follow the links at `fsimpl1`_ for implementations built into ``fsspec`` and `fsimpl2`_ for those not included in the main ``fsspec`` distribution."
msgstr ""

#: ../../source/user_guide/io.rst:1689
msgid "You can also pass parameters directly to the backend driver. Since ``fsspec`` does not utilize the ``AWS_S3_HOST`` environment variable, we can directly define a dictionary containing the endpoint_url and pass the object into the storage option parameter:"
msgstr ""

#: ../../source/user_guide/io.rst:1699
msgid "More sample configurations and documentation can be found at `S3Fs documentation <https://s3fs.readthedocs.io/en/latest/index.html?highlight=host#s3-compatible-storage>`__."
msgstr ""

#: ../../source/user_guide/io.rst:1702
msgid "If you do *not* have S3 credentials, you can still access public data by specifying an anonymous connection, such as"
msgstr ""

#: ../../source/user_guide/io.rst:1715
msgid "``fsspec`` also allows complex URLs, for accessing data in compressed archives, local caching of files, and more. To locally cache the above example, you would modify the call to"
msgstr ""

#: ../../source/user_guide/io.rst:1727
msgid "where we specify that the \"anon\" parameter is meant for the \"s3\" part of the implementation, not to the caching implementation. Note that this caches to a temporary directory for the duration of the session only, but you can also specify a permanent store."
msgstr ""

#: ../../source/user_guide/io.rst:1737
msgid "Writing out data"
msgstr ""

#: ../../source/user_guide/io.rst:1742
msgid "Writing to CSV format"
msgstr ""

#: ../../source/user_guide/io.rst:1744
msgid "The ``Series`` and ``DataFrame`` objects have an instance method ``to_csv`` which allows storing the contents of the object as a comma-separated-values file. The function takes a number of arguments. Only the first is required."
msgstr ""

#: ../../source/user_guide/io.rst:1748
msgid "``path_or_buf``: A string path to the file to write or a file object.  If a file object it must be opened with ``newline=''``"
msgstr ""

#: ../../source/user_guide/io.rst:1749
msgid "``sep`` : Field delimiter for the output file (default \",\")"
msgstr ""

#: ../../source/user_guide/io.rst:1750
msgid "``na_rep``: A string representation of a missing value (default '')"
msgstr ""

#: ../../source/user_guide/io.rst:1751
msgid "``float_format``: Format string for floating point numbers"
msgstr ""

#: ../../source/user_guide/io.rst:1752
msgid "``columns``: Columns to write (default None)"
msgstr ""

#: ../../source/user_guide/io.rst:1753
msgid "``header``: Whether to write out the column names (default True)"
msgstr ""

#: ../../source/user_guide/io.rst:1754
msgid "``index``: whether to write row (index) names (default True)"
msgstr ""

#: ../../source/user_guide/io.rst:1755
msgid "``index_label``: Column label(s) for index column(s) if desired. If None (default), and ``header`` and ``index`` are True, then the index names are used. (A sequence should be given if the ``DataFrame`` uses MultiIndex)."
msgstr ""

#: ../../source/user_guide/io.rst:1758
msgid "``mode`` : Python write mode, default 'w'"
msgstr ""

#: ../../source/user_guide/io.rst:1759
msgid "``encoding``: a string representing the encoding to use if the contents are non-ASCII, for Python versions prior to 3"
msgstr ""

#: ../../source/user_guide/io.rst:1761
msgid "``lineterminator``: Character sequence denoting line end (default ``os.linesep``)"
msgstr ""

#: ../../source/user_guide/io.rst:1762
msgid "``quoting``: Set quoting rules as in csv module (default csv.QUOTE_MINIMAL). Note that if you have set a ``float_format`` then floats are converted to strings and csv.QUOTE_NONNUMERIC will treat them as non-numeric"
msgstr ""

#: ../../source/user_guide/io.rst:1763
msgid "``quotechar``: Character used to quote fields (default '\"')"
msgstr ""

#: ../../source/user_guide/io.rst:1764
msgid "``doublequote``: Control quoting of ``quotechar`` in fields (default True)"
msgstr ""

#: ../../source/user_guide/io.rst:1765
msgid "``escapechar``: Character used to escape ``sep`` and ``quotechar`` when appropriate (default None)"
msgstr ""

#: ../../source/user_guide/io.rst:1767
msgid "``chunksize``: Number of rows to write at a time"
msgstr ""

#: ../../source/user_guide/io.rst:1768
msgid "``date_format``: Format string for datetime objects"
msgstr ""

#: ../../source/user_guide/io.rst:1771
msgid "Writing a formatted string"
msgstr ""

#: ../../source/user_guide/io.rst:1775
msgid "The ``DataFrame`` object has an instance method ``to_string`` which allows control over the string representation of the object. All arguments are optional:"
msgstr ""

#: ../../source/user_guide/io.rst:1778
msgid "``buf`` default None, for example a StringIO object"
msgstr ""

#: ../../source/user_guide/io.rst:1779
msgid "``columns`` default None, which columns to write"
msgstr ""

#: ../../source/user_guide/io.rst:1780
msgid "``col_space`` default None, minimum width of each column."
msgstr ""

#: ../../source/user_guide/io.rst:1781
msgid "``na_rep`` default ``NaN``, representation of NA value"
msgstr ""

#: ../../source/user_guide/io.rst:1782
msgid "``formatters`` default None, a dictionary (by column) of functions each of which takes a single argument and returns a formatted string"
msgstr ""

#: ../../source/user_guide/io.rst:1784
msgid "``float_format`` default None, a function which takes a single (float) argument and returns a formatted string; to be applied to floats in the ``DataFrame``."
msgstr ""

#: ../../source/user_guide/io.rst:1787
msgid "``sparsify`` default True, set to False for a ``DataFrame`` with a hierarchical index to print every MultiIndex key at each row."
msgstr ""

#: ../../source/user_guide/io.rst:1789
msgid "``index_names`` default True, will print the names of the indices"
msgstr ""

#: ../../source/user_guide/io.rst:1790
msgid "``index`` default True, will print the index (ie, row labels)"
msgstr ""

#: ../../source/user_guide/io.rst:1791
msgid "``header`` default True, will print the column labels"
msgstr ""

#: ../../source/user_guide/io.rst:1792
msgid "``justify`` default ``left``, will print column headers left- or right-justified"
msgstr ""

#: ../../source/user_guide/io.rst:1795
msgid "The ``Series`` object also has a ``to_string`` method, but with only the ``buf``, ``na_rep``, ``float_format`` arguments. There is also a ``length`` argument which, if set to ``True``, will additionally output the length of the Series."
msgstr ""

#: ../../source/user_guide/io.rst:1802
msgid "JSON"
msgstr ""

#: ../../source/user_guide/io.rst:1804
msgid "Read and write ``JSON`` format files and strings."
msgstr ""

#: ../../source/user_guide/io.rst:1809
msgid "Writing JSON"
msgstr ""

#: ../../source/user_guide/io.rst:1811
msgid "A ``Series`` or ``DataFrame`` can be converted to a valid JSON string. Use ``to_json`` with optional parameters:"
msgstr ""

#: ../../source/user_guide/io.rst:1814
msgid "``path_or_buf`` : the pathname or buffer to write the output This can be ``None`` in which case a JSON string is returned"
msgstr ""

#: ../../source/user_guide/io.rst:1816
#: ../../source/user_guide/io.rst:2011
msgid "``orient`` :"
msgstr ""

#: ../../source/user_guide/io.rst:1820
msgid "``Series``:"
msgstr ""

#: ../../source/user_guide/io.rst:1819
#: ../../source/user_guide/io.rst:2014
msgid "default is ``index``"
msgstr ""

#: ../../source/user_guide/io.rst:1820
#: ../../source/user_guide/io.rst:2015
msgid "allowed values are {``split``, ``records``, ``index``}"
msgstr ""

#: ../../source/user_guide/io.rst:1824
msgid "``DataFrame``:"
msgstr ""

#: ../../source/user_guide/io.rst:1823
#: ../../source/user_guide/io.rst:2018
msgid "default is ``columns``"
msgstr ""

#: ../../source/user_guide/io.rst:1824
#: ../../source/user_guide/io.rst:2019
msgid "allowed values are {``split``, ``records``, ``index``, ``columns``, ``values``, ``table``}"
msgstr ""

#: ../../source/user_guide/io.rst:1826
#: ../../source/user_guide/io.rst:2021
msgid "The format of the JSON string"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid "``split``"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid "dict like {index -> [index], columns -> [columns], data -> [values]}"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid "``records``"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid "list like [{column -> value}, ... , {column -> value}]"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid "``index``"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid "dict like {index -> {column -> value}}"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid "``columns``"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid "dict like {column -> {index -> value}}"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid "``values``"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid "just the values array"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid "``table``"
msgstr ""

#: ../../source/user_guide/io.rst:1
msgid "adhering to the JSON `Table Schema`_"
msgstr ""

#: ../../source/user_guide/io.rst:1839
msgid "``date_format`` : string, type of date conversion, 'epoch' for timestamp, 'iso' for ISO8601."
msgstr ""

#: ../../source/user_guide/io.rst:1840
msgid "``double_precision`` : The number of decimal places to use when encoding floating point values, default 10."
msgstr ""

#: ../../source/user_guide/io.rst:1841
msgid "``force_ascii`` : force encoded string to be ASCII, default True."
msgstr ""

#: ../../source/user_guide/io.rst:1842
msgid "``date_unit`` : The time unit to encode to, governs timestamp and ISO8601 precision. One of 's', 'ms', 'us' or 'ns' for seconds, milliseconds, microseconds and nanoseconds respectively. Default 'ms'."
msgstr ""

#: ../../source/user_guide/io.rst:1843
msgid "``default_handler`` : The handler to call if an object cannot otherwise be converted to a suitable format for JSON. Takes a single argument, which is the object to convert, and returns a serializable object."
msgstr ""

#: ../../source/user_guide/io.rst:1844
msgid "``lines`` : If ``records`` orient, then will write each record per line as json."
msgstr ""

#: ../../source/user_guide/io.rst:1845
msgid "``mode`` : string, writer mode when writing to path. 'w' for write, 'a' for append. Default 'w'"
msgstr ""

#: ../../source/user_guide/io.rst:1847
msgid "Note ``NaN``'s, ``NaT``'s and ``None`` will be converted to ``null`` and ``datetime`` objects will be converted based on the ``date_format`` and ``date_unit`` parameters."
msgstr ""

#: ../../source/user_guide/io.rst:1856
msgid "Orient options"
msgstr ""

#: ../../source/user_guide/io.rst:1858
msgid "There are a number of different options for the format of the resulting JSON file / string. Consider the following ``DataFrame`` and ``Series``:"
msgstr ""

#: ../../source/user_guide/io.rst:1872
msgid "**Column oriented** (the default for ``DataFrame``) serializes the data as nested JSON objects with column labels acting as the primary index:"
msgstr ""

#: ../../source/user_guide/io.rst:1880
msgid "**Index oriented** (the default for ``Series``) similar to column oriented but the index labels are now primary:"
msgstr ""

#: ../../source/user_guide/io.rst:1888
msgid "**Record oriented** serializes the data to a JSON array of column -> value records, index labels are not included. This is useful for passing ``DataFrame`` data to plotting libraries, for example the JavaScript library ``d3.js``:"
msgstr ""

#: ../../source/user_guide/io.rst:1897
msgid "**Value oriented** is a bare-bones option which serializes to nested JSON arrays of values only, column and index labels are not included:"
msgstr ""

#: ../../source/user_guide/io.rst:1905
msgid "**Split oriented** serializes to a JSON object containing separate entries for values, index and columns. Name is also included for ``Series``:"
msgstr ""

#: ../../source/user_guide/io.rst:1913
msgid "**Table oriented** serializes to the JSON `Table Schema`_, allowing for the preservation of metadata including but not limited to dtypes and index names."
msgstr ""

#: ../../source/user_guide/io.rst:1918
msgid "Any orient option that encodes to a JSON object will not preserve the ordering of index and column labels during round-trip serialization. If you wish to preserve label ordering use the ``split`` option as it uses ordered containers."
msgstr ""

#: ../../source/user_guide/io.rst:1923
msgid "Date handling"
msgstr ""

#: ../../source/user_guide/io.rst:1925
msgid "Writing in ISO date format:"
msgstr ""

#: ../../source/user_guide/io.rst:1935
msgid "Writing in ISO date format, with microseconds:"
msgstr ""

#: ../../source/user_guide/io.rst:1942
msgid "Epoch timestamps, in seconds:"
msgstr ""

#: ../../source/user_guide/io.rst:1949
msgid "Writing to a file, with a date index and a date column:"
msgstr ""

#: ../../source/user_guide/io.rst:1964
msgid "Fallback behavior"
msgstr ""

#: ../../source/user_guide/io.rst:1966
msgid "If the JSON serializer cannot handle the container contents directly it will fall back in the following manner:"
msgstr ""

#: ../../source/user_guide/io.rst:1969
msgid "if the dtype is unsupported (e.g. ``np.complex_``) then the ``default_handler``, if provided, will be called for each value, otherwise an exception is raised."
msgstr ""

#: ../../source/user_guide/io.rst:1972
msgid "if an object is unsupported it will attempt the following:"
msgstr ""

#: ../../source/user_guide/io.rst:1975
msgid "check if the object has defined a ``toDict`` method and call it. A ``toDict`` method should return a ``dict`` which will then be JSON serialized."
msgstr ""

#: ../../source/user_guide/io.rst:1978
msgid "invoke the ``default_handler`` if one was provided."
msgstr ""

#: ../../source/user_guide/io.rst:1980
msgid "convert the object to a ``dict`` by traversing its contents. However this will often fail with an ``OverflowError`` or give unexpected results."
msgstr ""

#: ../../source/user_guide/io.rst:1983
msgid "In general the best approach for unsupported objects or dtypes is to provide a ``default_handler``. For example:"
msgstr ""

#: ../../source/user_guide/io.rst:1991
msgid "can be dealt with by specifying a simple ``default_handler``:"
msgstr ""

#: ../../source/user_guide/io.rst:2000
msgid "Reading JSON"
msgstr ""

#: ../../source/user_guide/io.rst:2002
msgid "Reading a JSON string to pandas object can take a number of parameters. The parser will try to parse a ``DataFrame`` if ``typ`` is not supplied or is ``None``. To explicitly force ``Series`` parsing, pass ``typ=series``"
msgstr ""

#: ../../source/user_guide/io.rst:2006
msgid "``filepath_or_buffer`` : a **VALID** JSON string or file handle / StringIO. The string could be a URL. Valid URL schemes include http, ftp, S3, and file. For file URLs, a host is expected. For instance, a local file could be file ://localhost/path/to/table.json"
msgstr ""

#: ../../source/user_guide/io.rst:2010
msgid "``typ``    : type of object to recover (series or frame), default 'frame'"
msgstr ""

#: ../../source/user_guide/io.rst:2015
msgid "Series :"
msgstr ""

#: ../../source/user_guide/io.rst:2019
msgid "DataFrame"
msgstr ""

#: ../../source/user_guide/io.rst:2035
msgid "``dtype`` : if True, infer dtypes, if a dict of column to dtype, then use those, if ``False``, then don't infer dtypes at all, default is True, apply only to the data."
msgstr ""

#: ../../source/user_guide/io.rst:2036
msgid "``convert_axes`` : boolean, try to convert the axes to the proper dtypes, default is ``True``"
msgstr ""

#: ../../source/user_guide/io.rst:2037
msgid "``convert_dates`` : a list of columns to parse for dates; If ``True``, then try to parse date-like columns, default is ``True``."
msgstr ""

#: ../../source/user_guide/io.rst:2038
msgid "``keep_default_dates`` : boolean, default ``True``. If parsing dates, then parse the default date-like columns."
msgstr ""

#: ../../source/user_guide/io.rst:2039
msgid "``precise_float`` : boolean, default ``False``. Set to enable usage of higher precision (strtod) function when decoding string to double values. Default (``False``) is to use fast but less precise builtin functionality."
msgstr ""

#: ../../source/user_guide/io.rst:2040
msgid "``date_unit`` : string, the timestamp unit to detect if converting dates. Default None. By default the timestamp precision will be detected, if this is not desired then pass one of 's', 'ms', 'us' or 'ns' to force timestamp precision to seconds, milliseconds, microseconds or nanoseconds respectively."
msgstr ""

#: ../../source/user_guide/io.rst:2044
msgid "``lines`` : reads file as one json object per line."
msgstr ""

#: ../../source/user_guide/io.rst:2045
msgid "``encoding`` : The encoding to use to decode py3 bytes."
msgstr ""

#: ../../source/user_guide/io.rst:2046
msgid "``chunksize`` : when used in combination with ``lines=True``, return a ``pandas.api.typing.JsonReader`` which reads in ``chunksize`` lines per iteration."
msgstr ""

#: ../../source/user_guide/io.rst:2047
msgid "``engine``: Either ``\"ujson\"``, the built-in JSON parser, or ``\"pyarrow\"`` which dispatches to pyarrow's ``pyarrow.json.read_json``. The ``\"pyarrow\"`` is only available when ``lines=True``"
msgstr ""

#: ../../source/user_guide/io.rst:2050
msgid "The parser will raise one of ``ValueError/TypeError/AssertionError`` if the JSON is not parseable."
msgstr ""

#: ../../source/user_guide/io.rst:2052
msgid "If a non-default ``orient`` was used when encoding to JSON be sure to pass the same option here so that decoding produces sensible results, see `Orient Options`_ for an overview."
msgstr ""

#: ../../source/user_guide/io.rst:2057
msgid "Data conversion"
msgstr ""

#: ../../source/user_guide/io.rst:2059
msgid "The default of ``convert_axes=True``, ``dtype=True``, and ``convert_dates=True`` will try to parse the axes, and all of the data into appropriate types, including dates. If you need to override specific dtypes, pass a dict to ``dtype``. ``convert_axes`` should only be set to ``False`` if you need to preserve string-like numbers (e.g. '1', '2') in an axes."
msgstr ""

#: ../../source/user_guide/io.rst:2067
msgid "Large integer values may be converted to dates if ``convert_dates=True`` and the data and / or column labels appear 'date-like'. The exact threshold depends on the ``date_unit`` specified. 'date-like' means that the column label meets one of the following criteria:"
msgstr ""

#: ../../source/user_guide/io.rst:2069
msgid "it ends with ``'_at'``"
msgstr ""

#: ../../source/user_guide/io.rst:2070
msgid "it ends with ``'_time'``"
msgstr ""

#: ../../source/user_guide/io.rst:2071
msgid "it begins with ``'timestamp'``"
msgstr ""

#: ../../source/user_guide/io.rst:2072
msgid "it is ``'modified'``"
msgstr ""

#: ../../source/user_guide/io.rst:2073
msgid "it is ``'date'``"
msgstr ""

#: ../../source/user_guide/io.rst:2077
msgid "When reading JSON data, automatic coercing into dtypes has some quirks:"
msgstr ""

#: ../../source/user_guide/io.rst:2079
msgid "an index can be reconstructed in a different order from serialization, that is, the returned order is not guaranteed to be the same as before serialization"
msgstr ""

#: ../../source/user_guide/io.rst:2080
msgid "a column that was ``float`` data will be converted to ``integer`` if it can be done safely, e.g. a column of ``1.``"
msgstr ""

#: ../../source/user_guide/io.rst:2081
msgid "bool columns will be converted to ``integer`` on reconstruction"
msgstr ""

#: ../../source/user_guide/io.rst:2083
msgid "Thus there are times where you may want to specify specific dtypes via the ``dtype`` keyword argument."
msgstr ""

#: ../../source/user_guide/io.rst:2085
msgid "Reading from a JSON string:"
msgstr ""

#: ../../source/user_guide/io.rst:2092
msgid "Reading from a file:"
msgstr ""

#: ../../source/user_guide/io.rst:2098
msgid "Don't convert any data (but still convert axes and dates):"
msgstr ""

#: ../../source/user_guide/io.rst:2104
msgid "Specify dtypes for conversion:"
msgstr ""

#: ../../source/user_guide/io.rst:2110
msgid "Preserve string indices:"
msgstr ""

#: ../../source/user_guide/io.rst:2128
msgid "Dates written in nanoseconds need to be read back in nanoseconds:"
msgstr ""

#: ../../source/user_guide/io.rst:2147
#: ../../source/user_guide/io.rst:5370
msgid "By setting the ``dtype_backend`` argument you can control the default dtypes used for the resulting DataFrame."
msgstr ""

#: ../../source/user_guide/io.rst:2163
msgid "Normalization"
msgstr ""

#: ../../source/user_guide/io.rst:2165
msgid "pandas provides a utility function to take a dict or list of dicts and *normalize* this semi-structured data into a flat table."
msgstr ""

#: ../../source/user_guide/io.rst:2203
msgid "The max_level parameter provides more control over which level to end normalization. With max_level=1 the following snippet normalizes until 1st nesting level of the provided dict."
msgstr ""

#: ../../source/user_guide/io.rst:2223
msgid "Line delimited json"
msgstr ""

#: ../../source/user_guide/io.rst:2225
msgid "pandas is able to read and write line-delimited json files that are common in data processing pipelines using Hadoop or Spark."
msgstr ""

#: ../../source/user_guide/io.rst:2228
msgid "For line-delimited json files, pandas can also return an iterator which reads in ``chunksize`` lines at a time. This can be useful for large files or to read from a stream."
msgstr ""

#: ../../source/user_guide/io.rst:2247
msgid "Line-limited json can also be read using the pyarrow reader by specifying ``engine=\"pyarrow\"``."
msgstr ""

#: ../../source/user_guide/io.rst:2260
msgid "Table schema"
msgstr ""

#: ../../source/user_guide/io.rst:2262
msgid "`Table Schema`_ is a spec for describing tabular datasets as a JSON object. The JSON includes information on the field names, types, and other attributes. You can use the orient ``table`` to build a JSON string with two fields, ``schema`` and ``data``."
msgstr ""

#: ../../source/user_guide/io.rst:2280
msgid "The ``schema`` field contains the ``fields`` key, which itself contains a list of column name to type pairs, including the ``Index`` or ``MultiIndex`` (see below for a list of types). The ``schema`` field also contains a ``primaryKey`` field if the (Multi)index is unique."
msgstr ""

#: ../../source/user_guide/io.rst:2286
msgid "The second field, ``data``, contains the serialized data with the ``records`` orient. The index is included, and any datetimes are ISO 8601 formatted, as required by the Table Schema spec."
msgstr ""

#: ../../source/user_guide/io.rst:2291
msgid "The full list of types supported are described in the Table Schema spec. This table shows the mapping from pandas types:"
msgstr ""

#: ../../source/user_guide/io.rst:2295
msgid "pandas type"
msgstr ""

#: ../../source/user_guide/io.rst:2295
msgid "Table Schema type"
msgstr ""

#: ../../source/user_guide/io.rst:2297
msgid "int64"
msgstr ""

#: ../../source/user_guide/io.rst:2297
msgid "integer"
msgstr ""

#: ../../source/user_guide/io.rst:2298
msgid "float64"
msgstr ""

#: ../../source/user_guide/io.rst:2298
msgid "number"
msgstr ""

#: ../../source/user_guide/io.rst:2299
msgid "bool"
msgstr ""

#: ../../source/user_guide/io.rst:2299
#: ../../source/user_guide/io.rst:5103
msgid "boolean"
msgstr ""

#: ../../source/user_guide/io.rst:2300
msgid "datetime64[ns]"
msgstr ""

#: ../../source/user_guide/io.rst:2300
msgid "datetime"
msgstr ""

#: ../../source/user_guide/io.rst:2301
msgid "timedelta64[ns]"
msgstr ""

#: ../../source/user_guide/io.rst:2301
msgid "duration"
msgstr ""

#: ../../source/user_guide/io.rst:2302
msgid "categorical"
msgstr ""

#: ../../source/user_guide/io.rst:2302
msgid "any"
msgstr ""

#: ../../source/user_guide/io.rst:2303
msgid "object"
msgstr ""

#: ../../source/user_guide/io.rst:2303
msgid "str"
msgstr ""

#: ../../source/user_guide/io.rst:2306
msgid "A few notes on the generated table schema:"
msgstr ""

#: ../../source/user_guide/io.rst:2308
msgid "The ``schema`` object contains a ``pandas_version`` field. This contains the version of pandas' dialect of the schema, and will be incremented with each revision."
msgstr ""

#: ../../source/user_guide/io.rst:2311
msgid "All dates are converted to UTC when serializing. Even timezone naive values, which are treated as UTC with an offset of 0."
msgstr ""

#: ../../source/user_guide/io.rst:2321
msgid "datetimes with a timezone (before serializing), include an additional field ``tz`` with the time zone name (e.g. ``'US/Central'``)."
msgstr ""

#: ../../source/user_guide/io.rst:2329
msgid "Periods are converted to timestamps before serialization, and so have the same behavior of being converted to UTC. In addition, periods will contain and additional field ``freq`` with the period's frequency, e.g. ``'A-DEC'``."
msgstr ""

#: ../../source/user_guide/io.rst:2338
msgid "Categoricals use the ``any`` type and an ``enum`` constraint listing the set of possible values. Additionally, an ``ordered`` field is included:"
msgstr ""

#: ../../source/user_guide/io.rst:2346
msgid "A ``primaryKey`` field, containing an array of labels, is included *if the index is unique*:"
msgstr ""

#: ../../source/user_guide/io.rst:2354
msgid "The ``primaryKey`` behavior is the same with MultiIndexes, but in this case the ``primaryKey`` is an array:"
msgstr ""

#: ../../source/user_guide/io.rst:2362
msgid "The default naming roughly follows these rules:"
msgstr ""

#: ../../source/user_guide/io.rst:2364
msgid "For series, the ``object.name`` is used. If that's none, then the name is ``values``"
msgstr ""

#: ../../source/user_guide/io.rst:2366
msgid "For ``DataFrames``, the stringified version of the column name is used"
msgstr ""

#: ../../source/user_guide/io.rst:2367
msgid "For ``Index`` (not ``MultiIndex``), ``index.name`` is used, with a fallback to ``index`` if that is None."
msgstr ""

#: ../../source/user_guide/io.rst:2369
msgid "For ``MultiIndex``, ``mi.names`` is used. If any level has no name, then ``level_<i>`` is used."
msgstr ""

#: ../../source/user_guide/io.rst:2372
msgid "``read_json`` also accepts ``orient='table'`` as an argument. This allows for the preservation of metadata such as dtypes and index names in a round-trippable manner."
msgstr ""

#: ../../source/user_guide/io.rst:2395
msgid "Please note that the literal string 'index' as the name of an :class:`Index` is not round-trippable, nor are any names beginning with ``'level_'`` within a :class:`MultiIndex`. These are used by default in :func:`DataFrame.to_json` to indicate missing values and the subsequent read cannot distinguish the intent."
msgstr ""

#: ../../source/user_guide/io.rst:2413
msgid "When using ``orient='table'`` along with user-defined ``ExtensionArray``, the generated schema will contain an additional ``extDtype`` key in the respective ``fields`` element. This extra key is not standard but does enable JSON roundtrips for extension types (e.g. ``read_json(df.to_json(orient=\"table\"), orient=\"table\")``)."
msgstr ""

#: ../../source/user_guide/io.rst:2418
msgid "The ``extDtype`` key carries the name of the extension, if you have properly registered the ``ExtensionDtype``, pandas will use said name to perform a lookup into the registry and re-convert the serialized data into your custom dtype."
msgstr ""

#: ../../source/user_guide/io.rst:2426
msgid "HTML"
msgstr ""

#: ../../source/user_guide/io.rst:2431
msgid "Reading HTML content"
msgstr ""

#: ../../source/user_guide/io.rst:2435
msgid "We **highly encourage** you to read the :ref:`HTML Table Parsing gotchas <io.html.gotchas>` below regarding the issues surrounding the BeautifulSoup4/html5lib/lxml parsers."
msgstr ""

#: ../../source/user_guide/io.rst:2438
msgid "The top-level :func:`~pandas.io.html.read_html` function can accept an HTML string/file/URL and will parse HTML tables into list of pandas ``DataFrames``. Let's look at a few examples."
msgstr ""

#: ../../source/user_guide/io.rst:2444
msgid "``read_html`` returns a ``list`` of ``DataFrame`` objects, even if there is only a single table contained in the HTML content."
msgstr ""

#: ../../source/user_guide/io.rst:2447
#: ../../source/user_guide/io.rst:2965
msgid "Read a URL with no options:"
msgstr ""

#: ../../source/user_guide/io.rst:2471
msgid "The data from the above URL changes every Monday so the resulting data above may be slightly different."
msgstr ""

#: ../../source/user_guide/io.rst:2473
msgid "Read a URL while passing headers alongside the HTTP request:"
msgstr ""

#: ../../source/user_guide/io.rst:2512
msgid "We see above that the headers we passed are reflected in the HTTP request."
msgstr ""

#: ../../source/user_guide/io.rst:2514
msgid "Read in the content of the file from the above URL and pass it to ``read_html`` as a string:"
msgstr ""

#: ../../source/user_guide/io.rst:2544
msgid "You can even pass in an instance of ``StringIO`` if you so desire:"
msgstr ""

#: ../../source/user_guide/io.rst:2553
msgid "The following examples are not run by the IPython evaluator due to the fact that having so many network-accessing functions slows down the documentation build. If you spot an error or an example that doesn't run, please do not hesitate to report it over on `pandas GitHub issues page <https://github.com/pandas-dev/pandas/issues>`__."
msgstr ""

#: ../../source/user_guide/io.rst:2560
msgid "Read a URL and match a table that contains specific text:"
msgstr ""

#: ../../source/user_guide/io.rst:2567
msgid "Specify a header row (by default ``<th>`` or ``<td>`` elements located within a ``<thead>`` are used to form the column index, if multiple rows are contained within ``<thead>`` then a MultiIndex is created); if specified, the header row is taken from the data minus the parsed header elements (``<th>`` elements)."
msgstr ""

#: ../../source/user_guide/io.rst:2576
msgid "Specify an index column:"
msgstr ""

#: ../../source/user_guide/io.rst:2582
msgid "Specify a number of rows to skip:"
msgstr ""

#: ../../source/user_guide/io.rst:2588
msgid "Specify a number of rows to skip using a list (``range`` works as well):"
msgstr ""

#: ../../source/user_guide/io.rst:2595
msgid "Specify an HTML attribute:"
msgstr ""

#: ../../source/user_guide/io.rst:2603
msgid "Specify values that should be converted to NaN:"
msgstr ""

#: ../../source/user_guide/io.rst:2609
msgid "Specify whether to keep the default set of NaN values:"
msgstr ""

#: ../../source/user_guide/io.rst:2615
msgid "Specify converters for columns. This is useful for numerical text data that has leading zeros.  By default columns that are numerical are cast to numeric types and the leading zeros are lost. To avoid this, we can convert these columns to strings."
msgstr ""

#: ../../source/user_guide/io.rst:2630
msgid "Use some combination of the above:"
msgstr ""

#: ../../source/user_guide/io.rst:2636
msgid "Read in pandas ``to_html`` output (with some loss of floating point precision):"
msgstr ""

#: ../../source/user_guide/io.rst:2644
msgid "The ``lxml`` backend will raise an error on a failed parse if that is the only parser you provide. If you only have a single parser you can provide just a string, but it is considered good practice to pass a list with one string if, for example, the function expects a sequence of strings. You may use:"
msgstr ""

#: ../../source/user_guide/io.rst:2653
msgid "Or you could pass ``flavor='lxml'`` without a list:"
msgstr ""

#: ../../source/user_guide/io.rst:2659
msgid "However, if you have bs4 and html5lib installed and pass ``None`` or ``['lxml', 'bs4']`` then the parse will most likely succeed. Note that *as soon as a parse succeeds, the function will return*."
msgstr ""

#: ../../source/user_guide/io.rst:2667
msgid "Links can be extracted from cells along with the text using ``extract_links=\"all\"``."
msgstr ""

#: ../../source/user_guide/io.rst:2695
msgid "Writing to HTML files"
msgstr ""

#: ../../source/user_guide/io.rst:2697
msgid "``DataFrame`` objects have an instance method ``to_html`` which renders the contents of the ``DataFrame`` as an HTML table. The function arguments are as in the method ``to_string`` described above."
msgstr ""

#: ../../source/user_guide/io.rst:2703
msgid "Not all of the possible options for ``DataFrame.to_html`` are shown here for brevity's sake. See :func:`~pandas.core.frame.DataFrame.to_html` for the full set of options."
msgstr ""

#: ../../source/user_guide/io.rst:2709
msgid "In an HTML-rendering supported environment like a Jupyter Notebook, ``display(HTML(...))``` will render the raw HTML into the environment."
msgstr ""

#: ../../source/user_guide/io.rst:2722
msgid "The ``columns`` argument will limit the columns shown:"
msgstr ""

#: ../../source/user_guide/io.rst:2730
msgid "``float_format`` takes a Python callable to control the precision of floating point values:"
msgstr ""

#: ../../source/user_guide/io.rst:2740
msgid "``bold_rows`` will make the row labels bold by default, but you can turn that off:"
msgstr ""

#: ../../source/user_guide/io.rst:2750
msgid "The ``classes`` argument provides the ability to give the resulting HTML table CSS classes. Note that these classes are *appended* to the existing ``'dataframe'`` class."
msgstr ""

#: ../../source/user_guide/io.rst:2758
msgid "The ``render_links`` argument provides the ability to add hyperlinks to cells that contain URLs."
msgstr ""

#: ../../source/user_guide/io.rst:2773
msgid "Finally, the ``escape`` argument allows you to control whether the \"<\", \">\" and \"&\" characters escaped in the resulting HTML (by default it is ``True``). So to get the HTML without escaped characters pass ``escape=False``"
msgstr ""

#: ../../source/user_guide/io.rst:2781
msgid "Escaped:"
msgstr ""

#: ../../source/user_guide/io.rst:2789
msgid "Not escaped:"
msgstr ""

#: ../../source/user_guide/io.rst:2799
msgid "Some browsers may not show a difference in the rendering of the previous two HTML tables."
msgstr ""

#: ../../source/user_guide/io.rst:2806
msgid "HTML Table Parsing Gotchas"
msgstr ""

#: ../../source/user_guide/io.rst:2808
msgid "There are some versioning issues surrounding the libraries that are used to parse HTML tables in the top-level pandas io function ``read_html``."
msgstr ""

#: ../../source/user_guide/io.rst:2811
msgid "**Issues with** |lxml|_"
msgstr ""

#: ../../source/user_guide/io.rst:2813
#: ../../source/user_guide/io.rst:2839
msgid "Benefits"
msgstr ""

#: ../../source/user_guide/io.rst:2815
msgid "|lxml|_ is very fast."
msgstr ""

#: ../../source/user_guide/io.rst:2817
msgid "|lxml|_ requires Cython to install correctly."
msgstr ""

#: ../../source/user_guide/io.rst:2819
#: ../../source/user_guide/io.rst:2854
msgid "Drawbacks"
msgstr ""

#: ../../source/user_guide/io.rst:2821
msgid "|lxml|_ does *not* make any guarantees about the results of its parse *unless* it is given |svm|_."
msgstr ""

#: ../../source/user_guide/io.rst:2824
msgid "In light of the above, we have chosen to allow you, the user, to use the |lxml|_ backend, but **this backend will use** |html5lib|_ if |lxml|_ fails to parse"
msgstr ""

#: ../../source/user_guide/io.rst:2828
msgid "It is therefore *highly recommended* that you install both |BeautifulSoup4|_ and |html5lib|_, so that you will still get a valid result (provided everything else is valid) even if |lxml|_ fails."
msgstr ""

#: ../../source/user_guide/io.rst:2832
msgid "**Issues with** |BeautifulSoup4|_ **using** |lxml|_ **as a backend**"
msgstr ""

#: ../../source/user_guide/io.rst:2834
msgid "The above issues hold here as well since |BeautifulSoup4|_ is essentially just a wrapper around a parser backend."
msgstr ""

#: ../../source/user_guide/io.rst:2837
msgid "**Issues with** |BeautifulSoup4|_ **using** |html5lib|_ **as a backend**"
msgstr ""

#: ../../source/user_guide/io.rst:2841
msgid "|html5lib|_ is far more lenient than |lxml|_ and consequently deals with *real-life markup* in a much saner way rather than just, e.g., dropping an element without notifying you."
msgstr ""

#: ../../source/user_guide/io.rst:2845
msgid "|html5lib|_ *generates valid HTML5 markup from invalid markup automatically*. This is extremely important for parsing HTML tables, since it guarantees a valid document. However, that does NOT mean that it is \"correct\", since the process of fixing markup does not have a single definition."
msgstr ""

#: ../../source/user_guide/io.rst:2851
msgid "|html5lib|_ is pure Python and requires no additional build steps beyond its own installation."
msgstr ""

#: ../../source/user_guide/io.rst:2856
msgid "The biggest drawback to using |html5lib|_ is that it is slow as molasses.  However consider the fact that many tables on the web are not big enough for the parsing algorithm runtime to matter. It is more likely that the bottleneck will be in the process of reading the raw text from the URL over the web, i.e., IO (input-output). For very large tables, this might not be true."
msgstr ""

#: ../../source/user_guide/io.rst:2879
msgid "LaTeX"
msgstr ""

#: ../../source/user_guide/io.rst:2883
msgid "Currently there are no methods to read from LaTeX, only output methods."
msgstr ""

#: ../../source/user_guide/io.rst:2886
msgid "Writing to LaTeX files"
msgstr ""

#: ../../source/user_guide/io.rst:2890
msgid "DataFrame *and* Styler objects currently have a ``to_latex`` method. We recommend using the `Styler.to_latex() <../reference/api/pandas.io.formats.style.Styler.to_latex.rst>`__ method over `DataFrame.to_latex() <../reference/api/pandas.DataFrame.to_latex.rst>`__ due to the former's greater flexibility with conditional styling, and the latter's possible future deprecation."
msgstr ""

#: ../../source/user_guide/io.rst:2895
msgid "Review the documentation for `Styler.to_latex <../reference/api/pandas.io.formats.style.Styler.to_latex.rst>`__, which gives examples of conditional styling and explains the operation of its keyword arguments."
msgstr ""

#: ../../source/user_guide/io.rst:2899
msgid "For simple application the following pattern is sufficient."
msgstr ""

#: ../../source/user_guide/io.rst:2906
msgid "To format values before output, chain the `Styler.format <../reference/api/pandas.io.formats.style.Styler.format.rst>`__ method."
msgstr ""

#: ../../source/user_guide/io.rst:2914
msgid "XML"
msgstr ""

#: ../../source/user_guide/io.rst:2919
msgid "Reading XML"
msgstr ""

#: ../../source/user_guide/io.rst:2923
msgid "The top-level :func:`~pandas.io.xml.read_xml` function can accept an XML string/file/URL and will parse nodes and attributes into a pandas ``DataFrame``."
msgstr ""

#: ../../source/user_guide/io.rst:2928
msgid "Since there is no standard XML structure where design types can vary in many ways, ``read_xml`` works best with flatter, shallow versions. If an XML document is deeply nested, use the ``stylesheet`` feature to transform XML into a flatter version."
msgstr ""

#: ../../source/user_guide/io.rst:2933
#: ../../source/user_guide/io.rst:3299
msgid "Let's look at a few examples."
msgstr ""

#: ../../source/user_guide/io.rst:2935
msgid "Read an XML string:"
msgstr ""

#: ../../source/user_guide/io.rst:2972
msgid "Read in the content of the \"books.xml\" file and pass it to ``read_xml`` as a string:"
msgstr ""

#: ../../source/user_guide/io.rst:2985
msgid "Read in the content of the \"books.xml\" as instance of ``StringIO`` or ``BytesIO`` and pass it to ``read_xml``:"
msgstr ""

#: ../../source/user_guide/io.rst:3004
msgid "Even read XML from AWS S3 buckets such as NIH NCBI PMC Article Datasets providing Biomedical and Life Science Jorurnals:"
msgstr ""

#: ../../source/user_guide/io.rst:3016
msgid "With `lxml`_ as default ``parser``, you access the full-featured XML library that extends Python's ElementTree API. One powerful tool is ability to query nodes selectively or conditionally with more expressive XPath:"
msgstr ""

#: ../../source/user_guide/io.rst:3027
msgid "Specify only elements or only attributes to parse:"
msgstr ""

#: ../../source/user_guide/io.rst:3044
msgid "XML documents can have namespaces with prefixes and default namespaces without prefixes both of which are denoted with a special attribute ``xmlns``. In order to parse by node under a namespace context, ``xpath`` must reference a prefix."
msgstr ""

#: ../../source/user_guide/io.rst:3048
msgid "For example, below XML contains a namespace with prefix, ``doc``, and URI at ``https://example.com``. In order to parse ``doc:row`` nodes, ``namespaces`` must be used."
msgstr ""

#: ../../source/user_guide/io.rst:3078
msgid "Similarly, an XML document can have a default namespace without prefix. Failing to assign a temporary prefix will return no nodes and raise a ``ValueError``. But assigning *any* temporary name to correct URI allows parsing by nodes."
msgstr ""

#: ../../source/user_guide/io.rst:3108
msgid "However, if XPath does not reference node names such as default, ``/*``, then ``namespaces`` is not required."
msgstr ""

#: ../../source/user_guide/io.rst:3113
msgid "Since ``xpath`` identifies the parent of content to be parsed, only immediate desendants which include child nodes or current attributes are parsed. Therefore, ``read_xml`` will not parse the text of grandchildren or other descendants and will not parse attributes of any descendant. To retrieve lower level content, adjust xpath to lower level. For example,"
msgstr ""

#: ../../source/user_guide/io.rst:3141
msgid "shows the attribute ``sides`` on ``shape`` element was not parsed as expected since this attribute resides on the child of ``row`` element and not ``row`` element itself. In other words, ``sides`` attribute is a grandchild level descendant of ``row`` element. However, the ``xpath`` targets ``row`` element which covers only its children and attributes."
msgstr ""

#: ../../source/user_guide/io.rst:3147
msgid "With `lxml`_ as parser, you can flatten nested XML documents with an XSLT script which also can be string/file/URL types. As background, `XSLT`_ is a special-purpose language written in a special XML file that can transform original XML documents into other XML, HTML, even text (CSV, JSON, etc.) using an XSLT processor."
msgstr ""

#: ../../source/user_guide/io.rst:3156
msgid "For example, consider this somewhat nested structure of Chicago \"L\" Rides where station and rides elements encapsulate data in their own sections. With below XSLT, ``lxml`` can transform original nested document into a flatter output (as shown below for demonstration) for easier parse into ``DataFrame``:"
msgstr ""

#: ../../source/user_guide/io.rst:3242
msgid "For very large XML files that can range in hundreds of megabytes to gigabytes, :func:`pandas.read_xml` supports parsing such sizeable files using `lxml's iterparse`_ and `etree's iterparse`_ which are memory-efficient methods to iterate through an XML tree and extract specific elements and attributes. without holding entire tree in memory."
msgstr ""

#: ../../source/user_guide/io.rst:3252
msgid "To use this feature, you must pass a physical XML file path into ``read_xml`` and use the ``iterparse`` argument. Files should not be compressed or point to online sources but stored on local disk. Also, ``iterparse`` should be a dictionary where the key is the repeating nodes in document (which become the rows) and the value is a list of any element or attribute that is a descendant (i.e., child, grandchild) of repeating node. Since XPath is not used in this method, descendants do not need to share same relationship with one another. Below shows example of reading in Wikipedia's very large (12 GB+) latest article data dump."
msgstr ""

#: ../../source/user_guide/io.rst:3285
msgid "Writing XML"
msgstr ""

#: ../../source/user_guide/io.rst:3289
msgid "``DataFrame`` objects have an instance method ``to_xml`` which renders the contents of the ``DataFrame`` as an XML document."
msgstr ""

#: ../../source/user_guide/io.rst:3294
msgid "This method does not support special properties of XML including DTD, CData, XSD schemas, processing instructions, comments, and others. Only namespaces at the root level is supported. However, ``stylesheet`` allows design changes after initial output."
msgstr ""

#: ../../source/user_guide/io.rst:3301
msgid "Write an XML without options:"
msgstr ""

#: ../../source/user_guide/io.rst:3316
msgid "Write an XML with new root and row name:"
msgstr ""

#: ../../source/user_guide/io.rst:3322
msgid "Write an attribute-centric XML:"
msgstr ""

#: ../../source/user_guide/io.rst:3328
msgid "Write a mix of elements and attributes:"
msgstr ""

#: ../../source/user_guide/io.rst:3339
msgid "Any ``DataFrames`` with hierarchical columns will be flattened for XML element names with levels delimited by underscores:"
msgstr ""

#: ../../source/user_guide/io.rst:3361
msgid "Write an XML with default namespace:"
msgstr ""

#: ../../source/user_guide/io.rst:3367
msgid "Write an XML with namespace prefix:"
msgstr ""

#: ../../source/user_guide/io.rst:3376
msgid "Write an XML without declaration or pretty print:"
msgstr ""

#: ../../source/user_guide/io.rst:3385
msgid "Write an XML and transform with stylesheet:"
msgstr ""

#: ../../source/user_guide/io.rst:3414
msgid "XML Final Notes"
msgstr ""

#: ../../source/user_guide/io.rst:3416
msgid "All XML documents adhere to `W3C specifications`_. Both ``etree`` and ``lxml`` parsers will fail to parse any markup document that is not well-formed or follows XML syntax rules. Do be aware HTML is not an XML document unless it follows XHTML specs. However, other popular markup types including KML, XAML, RSS, MusicML, MathML are compliant `XML schemas`_."
msgstr ""

#: ../../source/user_guide/io.rst:3422
msgid "For above reason, if your application builds XML prior to pandas operations, use appropriate DOM libraries like ``etree`` and ``lxml`` to build the necessary document and not by string concatenation or regex adjustments. Always remember XML is a *special* text file with markup rules."
msgstr ""

#: ../../source/user_guide/io.rst:3427
msgid "With very large XML files (several hundred MBs to GBs), XPath and XSLT can become memory-intensive operations. Be sure to have enough available RAM for reading and writing to large XML files (roughly about 5 times the size of text)."
msgstr ""

#: ../../source/user_guide/io.rst:3432
msgid "Because XSLT is a programming language, use it with caution since such scripts can pose a security risk in your environment and can run large or infinite recursive operations. Always test scripts on small fragments before full run."
msgstr ""

#: ../../source/user_guide/io.rst:3436
msgid "The `etree`_ parser supports all functionality of both ``read_xml`` and ``to_xml`` except for complex XPath and any XSLT. Though limited in features, ``etree`` is still a reliable and capable parser and tree builder. Its performance may trail ``lxml`` to a certain degree for larger files but relatively unnoticeable on small to medium size files."
msgstr ""

#: ../../source/user_guide/io.rst:3451
msgid "Excel files"
msgstr ""

#: ../../source/user_guide/io.rst:3453
msgid "The :func:`~pandas.read_excel` method can read Excel 2007+ (``.xlsx``) files using the ``openpyxl`` Python module. Excel 2003 (``.xls``) files can be read using ``xlrd``. Binary Excel (``.xlsb``) files can be read using ``pyxlsb``. The :meth:`~DataFrame.to_excel` instance method is used for saving a ``DataFrame`` to Excel.  Generally the semantics are similar to working with :ref:`csv<io.read_csv_table>` data. See the :ref:`cookbook<cookbook.excel>` for some advanced strategies."
msgstr ""

#: ../../source/user_guide/io.rst:3464
msgid "The `xlrd <https://xlrd.readthedocs.io/en/latest/>`__ package is now only for reading old-style ``.xls`` files."
msgstr ""

#: ../../source/user_guide/io.rst:3467
msgid "Before pandas 1.3.0, the default argument ``engine=None`` to :func:`~pandas.read_excel` would result in using the ``xlrd`` engine in many cases, including new Excel 2007+ (``.xlsx``) files. pandas will now default to using the `openpyxl <https://openpyxl.readthedocs.io/en/stable/>`__ engine."
msgstr ""

#: ../../source/user_guide/io.rst:3472
msgid "It is strongly encouraged to install ``openpyxl`` to read Excel 2007+ (``.xlsx``) files. **Please do not report issues when using ``xlrd`` to read ``.xlsx`` files.** This is no longer supported, switch to using ``openpyxl`` instead."
msgstr ""

#: ../../source/user_guide/io.rst:3480
msgid "Reading Excel files"
msgstr ""

#: ../../source/user_guide/io.rst:3482
msgid "In the most basic use-case, ``read_excel`` takes a path to an Excel file, and the ``sheet_name`` indicating which sheet to parse."
msgstr ""

#: ../../source/user_guide/io.rst:3485
#: ../../source/user_guide/io.rst:3809
msgid "When using the ``engine_kwargs`` parameter, pandas will pass these arguments to the engine. For this, it is important to know which function pandas is using internally."
msgstr ""

#: ../../source/user_guide/io.rst:3489
msgid "For the engine openpyxl, pandas is using :func:`openpyxl.load_workbook` to read in (``.xlsx``) and (``.xlsm``) files."
msgstr ""

#: ../../source/user_guide/io.rst:3491
msgid "For the engine xlrd, pandas is using :func:`xlrd.open_workbook` to read in (``.xls``) files."
msgstr ""

#: ../../source/user_guide/io.rst:3493
msgid "For the engine pyxlsb, pandas is using :func:`pyxlsb.open_workbook` to read in (``.xlsb``) files."
msgstr ""

#: ../../source/user_guide/io.rst:3495
msgid "For the engine odf, pandas is using :func:`odf.opendocument.load` to read in (``.ods``) files."
msgstr ""

#: ../../source/user_guide/io.rst:3506
msgid "``ExcelFile`` class"
msgstr ""

#: ../../source/user_guide/io.rst:3508
msgid "To facilitate working with multiple sheets from the same file, the ``ExcelFile`` class can be used to wrap the file and can be passed into ``read_excel`` There will be a performance benefit for reading multiple sheets as the file is read into memory only once."
msgstr ""

#: ../../source/user_guide/io.rst:3518
msgid "The ``ExcelFile`` class can also be used as a context manager."
msgstr ""

#: ../../source/user_guide/io.rst:3526
msgid "The ``sheet_names`` property will generate a list of the sheet names in the file."
msgstr ""

#: ../../source/user_guide/io.rst:3529
msgid "The primary use-case for an ``ExcelFile`` is parsing multiple sheets with different parameters:"
msgstr ""

#: ../../source/user_guide/io.rst:3540
msgid "Note that if the same parsing parameters are used for all sheets, a list of sheet names can simply be passed to ``read_excel`` with no loss in performance."
msgstr ""

#: ../../source/user_guide/io.rst:3556
msgid "``ExcelFile`` can also be called with a ``xlrd.book.Book`` object as a parameter. This allows the user to control how the excel file is read. For example, sheets can be loaded on demand by calling ``xlrd.open_workbook()`` with ``on_demand=True``."
msgstr ""

#: ../../source/user_guide/io.rst:3573
msgid "Specifying sheets"
msgstr ""

#: ../../source/user_guide/io.rst:3575
msgid "The second argument is ``sheet_name``, not to be confused with ``ExcelFile.sheet_names``."
msgstr ""

#: ../../source/user_guide/io.rst:3577
msgid "An ExcelFile's attribute ``sheet_names`` provides access to a list of sheets."
msgstr ""

#: ../../source/user_guide/io.rst:3579
msgid "The arguments ``sheet_name`` allows specifying the sheet or sheets to read."
msgstr ""

#: ../../source/user_guide/io.rst:3580
msgid "The default value for ``sheet_name`` is 0, indicating to read the first sheet"
msgstr ""

#: ../../source/user_guide/io.rst:3581
msgid "Pass a string to refer to the name of a particular sheet in the workbook."
msgstr ""

#: ../../source/user_guide/io.rst:3582
msgid "Pass an integer to refer to the index of a sheet. Indices follow Python convention, beginning at 0."
msgstr ""

#: ../../source/user_guide/io.rst:3584
msgid "Pass a list of either strings or integers, to return a dictionary of specified sheets."
msgstr ""

#: ../../source/user_guide/io.rst:3585
msgid "Pass a ``None`` to return a dictionary of all available sheets."
msgstr ""

#: ../../source/user_guide/io.rst:3592
msgid "Using the sheet index:"
msgstr ""

#: ../../source/user_guide/io.rst:3599
msgid "Using all default values:"
msgstr ""

#: ../../source/user_guide/io.rst:3606
msgid "Using None to get all sheets:"
msgstr ""

#: ../../source/user_guide/io.rst:3613
msgid "Using a list to get multiple sheets:"
msgstr ""

#: ../../source/user_guide/io.rst:3620
msgid "``read_excel`` can read more than one sheet, by setting ``sheet_name`` to either a list of sheet names, a list of sheet positions, or ``None`` to read all sheets. Sheets can be specified by sheet index or sheet name, using an integer or string, respectively."
msgstr ""

#: ../../source/user_guide/io.rst:3628
msgid "Reading a ``MultiIndex``"
msgstr ""

#: ../../source/user_guide/io.rst:3630
msgid "``read_excel`` can read a ``MultiIndex`` index, by passing a list of columns to ``index_col`` and a ``MultiIndex`` column by passing a list of rows to ``header``.  If either the ``index`` or ``columns`` have serialized level names those will be read in as well by specifying the rows/columns that make up the levels."
msgstr ""

#: ../../source/user_guide/io.rst:3635
msgid "For example, to read in a ``MultiIndex`` index without names:"
msgstr ""

#: ../../source/user_guide/io.rst:3647
msgid "If the index has level names, they will parsed as well, using the same parameters."
msgstr ""

#: ../../source/user_guide/io.rst:3658
msgid "If the source file has both ``MultiIndex`` index and columns, lists specifying each should be passed to ``index_col`` and ``header``:"
msgstr ""

#: ../../source/user_guide/io.rst:3673
msgid "Missing values in columns specified in ``index_col`` will be forward filled to allow roundtripping with ``to_excel`` for ``merged_cells=True``. To avoid forward filling the missing values use ``set_index`` after reading the data instead of ``index_col``."
msgstr ""

#: ../../source/user_guide/io.rst:3679
msgid "Parsing specific columns"
msgstr ""

#: ../../source/user_guide/io.rst:3681
msgid "It is often the case that users will insert columns to do temporary computations in Excel and you may not want to read in those columns. ``read_excel`` takes a ``usecols`` keyword to allow you to specify a subset of columns to parse."
msgstr ""

#: ../../source/user_guide/io.rst:3685
msgid "You can specify a comma-delimited set of Excel columns and ranges as a string:"
msgstr ""

#: ../../source/user_guide/io.rst:3691
msgid "If ``usecols`` is a list of integers, then it is assumed to be the file column indices to be parsed."
msgstr ""

#: ../../source/user_guide/io.rst:3698
msgid "Element order is ignored, so ``usecols=[0, 1]`` is the same as ``[1, 0]``."
msgstr ""

#: ../../source/user_guide/io.rst:3700
msgid "If ``usecols`` is a list of strings, it is assumed that each string corresponds to a column name provided either by the user in ``names`` or inferred from the document header row(s). Those strings define which columns will be parsed:"
msgstr ""

#: ../../source/user_guide/io.rst:3708
msgid "Element order is ignored, so ``usecols=['baz', 'joe']`` is the same as ``['joe', 'baz']``."
msgstr ""

#: ../../source/user_guide/io.rst:3710
msgid "If ``usecols`` is callable, the callable function will be evaluated against the column names, returning names where the callable function evaluates to ``True``."
msgstr ""

#: ../../source/user_guide/io.rst:3718
msgid "Parsing dates"
msgstr ""

#: ../../source/user_guide/io.rst:3720
msgid "Datetime-like values are normally automatically converted to the appropriate dtype when reading the excel file. But if you have a column of strings that *look* like dates (but are not actually formatted as dates in excel), you can use the ``parse_dates`` keyword to parse those strings to datetimes:"
msgstr ""

#: ../../source/user_guide/io.rst:3731
msgid "Cell converters"
msgstr ""

#: ../../source/user_guide/io.rst:3733
msgid "It is possible to transform the contents of Excel cells via the ``converters`` option. For instance, to convert a column to boolean:"
msgstr ""

#: ../../source/user_guide/io.rst:3740
msgid "This options handles missing values and treats exceptions in the converters as missing data. Transformations are applied cell by cell rather than to the column as a whole, so the array dtype is not guaranteed. For instance, a column of integers with missing values cannot be transformed to an array with integer dtype, because NaN is strictly a float. You can manually mask missing data to recover integer dtype:"
msgstr ""

#: ../../source/user_guide/io.rst:3756
msgid "Dtype specifications"
msgstr ""

#: ../../source/user_guide/io.rst:3758
msgid "As an alternative to converters, the type for an entire column can be specified using the ``dtype`` keyword, which takes a dictionary mapping column names to types.  To interpret data with no type inference, use the type ``str`` or ``object``."
msgstr ""

#: ../../source/user_guide/io.rst:3770
msgid "Writing Excel files"
msgstr ""

#: ../../source/user_guide/io.rst:3773
msgid "Writing Excel files to disk"
msgstr ""

#: ../../source/user_guide/io.rst:3775
msgid "To write a ``DataFrame`` object to a sheet of an Excel file, you can use the ``to_excel`` instance method.  The arguments are largely the same as ``to_csv`` described above, the first argument being the name of the excel file, and the optional second argument the name of the sheet to which the ``DataFrame`` should be written. For example:"
msgstr ""

#: ../../source/user_guide/io.rst:3785
msgid "Files with a ``.xlsx`` extension will be written using ``xlsxwriter`` (if available) or ``openpyxl``."
msgstr ""

#: ../../source/user_guide/io.rst:3789
msgid "The ``DataFrame`` will be written in a way that tries to mimic the REPL output. The ``index_label`` will be placed in the second row instead of the first. You can place it in the first row by setting the ``merge_cells`` option in ``to_excel()`` to ``False``:"
msgstr ""

#: ../../source/user_guide/io.rst:3798
msgid "In order to write separate ``DataFrames`` to separate sheets in a single Excel file, one can pass an :class:`~pandas.io.excel.ExcelWriter`."
msgstr ""

#: ../../source/user_guide/io.rst:3812
msgid "For the engine openpyxl, pandas is using :func:`openpyxl.Workbook` to create a new sheet and :func:`openpyxl.load_workbook` to append data to an existing sheet. The openpyxl engine writes to (``.xlsx``) and (``.xlsm``) files."
msgstr ""

#: ../../source/user_guide/io.rst:3814
msgid "For the engine xlsxwriter, pandas is using :func:`xlsxwriter.Workbook` to write to (``.xlsx``) files."
msgstr ""

#: ../../source/user_guide/io.rst:3816
msgid "For the engine odf, pandas is using :func:`odf.opendocument.OpenDocumentSpreadsheet` to write to (``.ods``) files."
msgstr ""

#: ../../source/user_guide/io.rst:3819
msgid "Writing Excel files to memory"
msgstr ""

#: ../../source/user_guide/io.rst:3821
msgid "pandas supports writing Excel files to buffer-like objects such as ``StringIO`` or ``BytesIO`` using :class:`~pandas.io.excel.ExcelWriter`."
msgstr ""

#: ../../source/user_guide/io.rst:3843
msgid "``engine`` is optional but recommended.  Setting the engine determines the version of workbook produced. Setting ``engine='xlrd'`` will produce an Excel 2003-format workbook (xls).  Using either ``'openpyxl'`` or ``'xlsxwriter'`` will produce an Excel 2007-format workbook (xlsx). If omitted, an Excel 2007-formatted workbook is produced."
msgstr ""

#: ../../source/user_guide/io.rst:3853
msgid "Excel writer engines"
msgstr ""

#: ../../source/user_guide/io.rst:3855
msgid "pandas chooses an Excel writer via two methods:"
msgstr ""

#: ../../source/user_guide/io.rst:3857
msgid "the ``engine`` keyword argument"
msgstr ""

#: ../../source/user_guide/io.rst:3858
msgid "the filename extension (via the default specified in config options)"
msgstr ""

#: ../../source/user_guide/io.rst:3860
msgid "By default, pandas uses the `XlsxWriter`_  for ``.xlsx``, `openpyxl`_ for ``.xlsm``. If you have multiple engines installed, you can set the default engine through :ref:`setting the config options <options>` ``io.excel.xlsx.writer`` and ``io.excel.xls.writer``. pandas will fall back on `openpyxl`_ for ``.xlsx`` files if `Xlsxwriter`_ is not available."
msgstr ""

#: ../../source/user_guide/io.rst:3870
msgid "To specify which writer you want to use, you can pass an engine keyword argument to ``to_excel`` and to ``ExcelWriter``. The built-in engines are:"
msgstr ""

#: ../../source/user_guide/io.rst:3873
msgid "``openpyxl``: version 2.4 or higher is required"
msgstr ""

#: ../../source/user_guide/io.rst:3874
msgid "``xlsxwriter``"
msgstr ""

#: ../../source/user_guide/io.rst:3894
msgid "Style and formatting"
msgstr ""

#: ../../source/user_guide/io.rst:3896
msgid "The look and feel of Excel worksheets created from pandas can be modified using the following parameters on the ``DataFrame``'s ``to_excel`` method."
msgstr ""

#: ../../source/user_guide/io.rst:3898
msgid "``float_format`` : Format string for floating point numbers (default ``None``)."
msgstr ""

#: ../../source/user_guide/io.rst:3899
msgid "``freeze_panes`` : A tuple of two integers representing the bottommost row and rightmost column to freeze. Each of these parameters is one-based, so (1, 1) will freeze the first row and first column (default ``None``)."
msgstr ""

#: ../../source/user_guide/io.rst:3901
msgid "Using the `Xlsxwriter`_ engine provides many options for controlling the format of an Excel worksheet created with the ``to_excel`` method.  Excellent examples can be found in the `Xlsxwriter`_ documentation here: https://xlsxwriter.readthedocs.io/working_with_pandas.html"
msgstr ""

#: ../../source/user_guide/io.rst:3908
msgid "OpenDocument Spreadsheets"
msgstr ""

#: ../../source/user_guide/io.rst:3910
msgid "The io methods for `Excel files`_ also support reading and writing OpenDocument spreadsheets using the `odfpy <https://pypi.org/project/odfpy/>`__ module. The semantics and features for reading and writing OpenDocument spreadsheets match what can be done for `Excel files`_ using ``engine='odf'``. The optional dependency 'odfpy' needs to be installed."
msgstr ""

#: ../../source/user_guide/io.rst:3915
msgid "The :func:`~pandas.read_excel` method can read OpenDocument spreadsheets"
msgstr ""

#: ../../source/user_guide/io.rst:3922
msgid "Similarly, the :func:`~pandas.to_excel` method can write OpenDocument spreadsheets"
msgstr ""

#: ../../source/user_guide/io.rst:3932
msgid "Binary Excel (.xlsb) files"
msgstr ""

#: ../../source/user_guide/io.rst:3934
msgid "The :func:`~pandas.read_excel` method can also read binary Excel files using the ``pyxlsb`` module. The semantics and features for reading binary Excel files mostly match what can be done for `Excel files`_ using ``engine='pyxlsb'``. ``pyxlsb`` does not recognize datetime types in files and will return floats instead."
msgstr ""

#: ../../source/user_guide/io.rst:3947
msgid "Currently pandas only supports *reading* binary Excel files. Writing is not implemented."
msgstr ""

#: ../../source/user_guide/io.rst:3954
msgid "Clipboard"
msgstr ""

#: ../../source/user_guide/io.rst:3956
msgid "A handy way to grab data is to use the :meth:`~DataFrame.read_clipboard` method, which takes the contents of the clipboard buffer and passes them to the ``read_csv`` method. For instance, you can copy the following text to the clipboard (CTRL-C on many operating systems):"
msgstr ""

#: ../../source/user_guide/io.rst:3968
msgid "And then import the data directly to a ``DataFrame`` by calling:"
msgstr ""

#: ../../source/user_guide/io.rst:3979
msgid "The ``to_clipboard`` method can be used to write the contents of a ``DataFrame`` to the clipboard. Following which you can paste the clipboard contents into other applications (CTRL-V on many operating systems). Here we illustrate writing a ``DataFrame`` into clipboard and reading it back."
msgstr ""

#: ../../source/user_guide/io.rst:4002
msgid "We can see that we got the same content back, which we had earlier written to the clipboard."
msgstr ""

#: ../../source/user_guide/io.rst:4006
msgid "You may need to install xclip or xsel (with PyQt5, PyQt4 or qtpy) on Linux to use these methods."
msgstr ""

#: ../../source/user_guide/io.rst:4011
msgid "Pickling"
msgstr ""

#: ../../source/user_guide/io.rst:4013
msgid "All pandas objects are equipped with ``to_pickle`` methods which use Python's ``cPickle`` module to save data structures to disk using the pickle format."
msgstr ""

#: ../../source/user_guide/io.rst:4021
msgid "The ``read_pickle`` function in the ``pandas`` namespace can be used to load any pickled pandas object (or any other pickled object) from file:"
msgstr ""

#: ../../source/user_guide/io.rst:4036
msgid "Loading pickled data received from untrusted sources can be unsafe."
msgstr ""

#: ../../source/user_guide/io.rst:4038
msgid "See: https://docs.python.org/3/library/pickle.html"
msgstr ""

#: ../../source/user_guide/io.rst:4042
msgid ":func:`read_pickle` is only guaranteed backwards compatible back to a few minor release."
msgstr ""

#: ../../source/user_guide/io.rst:4047
msgid "Compressed pickle files"
msgstr ""

#: ../../source/user_guide/io.rst:4049
msgid ":func:`read_pickle`, :meth:`DataFrame.to_pickle` and :meth:`Series.to_pickle` can read and write compressed pickle files. The compression types of ``gzip``, ``bz2``, ``xz``, ``zstd`` are supported for reading and writing. The ``zip`` file format only supports reading and must contain only one data file to be read."
msgstr ""

#: ../../source/user_guide/io.rst:4054
msgid "The compression type can be an explicit parameter or be inferred from the file extension. If 'infer', then use ``gzip``, ``bz2``, ``zip``, ``xz``, ``zstd`` if filename ends in ``'.gz'``, ``'.bz2'``, ``'.zip'``, ``'.xz'``, or ``'.zst'``, respectively."
msgstr ""

#: ../../source/user_guide/io.rst:4058
msgid "The compression parameter can also be a ``dict`` in order to pass options to the compression protocol. It must have a ``'method'`` key set to the name of the compression protocol, which must be one of {``'zip'``, ``'gzip'``, ``'bz2'``, ``'xz'``, ``'zstd'``}. All other key-value pairs are passed to the underlying compression library."
msgstr ""

#: ../../source/user_guide/io.rst:4075
msgid "Using an explicit compression type:"
msgstr ""

#: ../../source/user_guide/io.rst:4083
msgid "Inferring compression type from the extension:"
msgstr ""

#: ../../source/user_guide/io.rst:4091
msgid "The default is to 'infer':"
msgstr ""

#: ../../source/user_guide/io.rst:4103
msgid "Passing options to the compression protocol in order to speed up compression:"
msgstr ""

#: ../../source/user_guide/io.rst:4120
msgid "msgpack"
msgstr ""

#: ../../source/user_guide/io.rst:4122
msgid "pandas support for ``msgpack`` has been removed in version 1.0.0. It is recommended to use :ref:`pickle <io.pickle>` instead."
msgstr ""

#: ../../source/user_guide/io.rst:4125
msgid "Alternatively, you can also the Arrow IPC serialization format for on-the-wire transmission of pandas objects. For documentation on pyarrow, see `here <https://arrow.apache.org/docs/python/ipc.html>`__."
msgstr ""

#: ../../source/user_guide/io.rst:4133
msgid "HDF5 (PyTables)"
msgstr ""

#: ../../source/user_guide/io.rst:4135
msgid "``HDFStore`` is a dict-like object which reads and writes pandas using the high performance HDF5 format using the excellent `PyTables <https://www.pytables.org/>`__ library. See the :ref:`cookbook <cookbook.hdf>` for some advanced strategies"
msgstr ""

#: ../../source/user_guide/io.rst:4142
msgid "pandas uses PyTables for reading and writing HDF5 files, which allows serializing object-dtype data with pickle. Loading pickled data received from untrusted sources can be unsafe."
msgstr ""

#: ../../source/user_guide/io.rst:4146
msgid "See: https://docs.python.org/3/library/pickle.html for more."
msgstr ""

#: ../../source/user_guide/io.rst:4159
msgid "Objects can be written to the file just like adding key-value pairs to a dict:"
msgstr ""

#: ../../source/user_guide/io.rst:4175
msgid "In a current or later Python session, you can retrieve stored objects:"
msgstr ""

#: ../../source/user_guide/io.rst:4185
msgid "Deletion of the object specified by the key:"
msgstr ""

#: ../../source/user_guide/io.rst:4194
msgid "Closing a Store and using a context manager:"
msgstr ""

#: ../../source/user_guide/io.rst:4215
msgid "Read/write API"
msgstr ""

#: ../../source/user_guide/io.rst:4217
msgid "``HDFStore`` supports a top-level API using  ``read_hdf`` for reading and ``to_hdf`` for writing, similar to how ``read_csv`` and ``to_csv`` work."
msgstr ""

#: ../../source/user_guide/io.rst:4233
msgid "HDFStore will by default not drop rows that are all missing. This behavior can be changed by setting ``dropna=True``."
msgstr ""

#: ../../source/user_guide/io.rst:4265
msgid "Fixed format"
msgstr ""

#: ../../source/user_guide/io.rst:4267
msgid "The examples above show storing using ``put``, which write the HDF5 to ``PyTables`` in a fixed array format, called the ``fixed`` format. These types of stores are **not** appendable once written (though you can simply remove them and rewrite). Nor are they **queryable**; they must be retrieved in their entirety. They also do not support dataframes with non-unique column names. The ``fixed`` format stores offer very fast writing and slightly faster reading than ``table`` stores. This format is specified by default when using ``put`` or ``to_hdf`` or by ``format='fixed'`` or ``format='f'``."
msgstr ""

#: ../../source/user_guide/io.rst:4276
msgid "A ``fixed`` format will raise a ``TypeError`` if you try to retrieve using a ``where``:"
msgstr ""

#: ../../source/user_guide/io.rst:4293
msgid "Table format"
msgstr ""

#: ../../source/user_guide/io.rst:4295
msgid "``HDFStore`` supports another ``PyTables`` format on disk, the ``table`` format. Conceptually a ``table`` is shaped very much like a DataFrame, with rows and columns. A ``table`` may be appended to in the same or other sessions.  In addition, delete and query type operations are supported. This format is specified by ``format='table'`` or ``format='t'`` to ``append`` or ``put`` or ``to_hdf``."
msgstr ""

#: ../../source/user_guide/io.rst:4302
msgid "This format can be set as an option as well ``pd.set_option('io.hdf.default_format','table')`` to enable ``put/append/to_hdf`` to by default store in the ``table`` format."
msgstr ""

#: ../../source/user_guide/io.rst:4330
msgid "You can also create a ``table`` by passing ``format='table'`` or ``format='t'`` to a ``put`` operation."
msgstr ""

#: ../../source/user_guide/io.rst:4335
msgid "Hierarchical keys"
msgstr ""

#: ../../source/user_guide/io.rst:4337
msgid "Keys to a store can be specified as a string. These can be in a hierarchical path-name like format (e.g. ``foo/bar/bah``), which will generate a hierarchy of sub-stores (or ``Groups`` in PyTables parlance). Keys can be specified without the leading '/' and are **always** absolute (e.g. 'foo' refers to '/foo'). Removal operations can remove everything in the sub-store and **below**, so be *careful*."
msgstr ""

#: ../../source/user_guide/io.rst:4359
msgid "You can walk through the group hierarchy using the ``walk`` method which will yield a tuple for each group key along with the relative keys of its contents."
msgstr ""

#: ../../source/user_guide/io.rst:4376
msgid "Hierarchical keys cannot be retrieved as dotted (attribute) access as described above for items stored under the root node."
msgstr ""

#: ../../source/user_guide/io.rst:4388
msgid "Instead, use explicit string based keys:"
msgstr ""

#: ../../source/user_guide/io.rst:4398
msgid "Storing types"
msgstr ""

#: ../../source/user_guide/io.rst:4401
msgid "Storing mixed types in a table"
msgstr ""

#: ../../source/user_guide/io.rst:4403
msgid "Storing mixed-dtype data is supported. Strings are stored as a fixed-width using the maximum size of the appended column. Subsequent attempts at appending longer strings will raise a ``ValueError``."
msgstr ""

#: ../../source/user_guide/io.rst:4407
msgid "Passing ``min_itemsize={`values`: size}`` as a parameter to append will set a larger minimum for the string columns. Storing ``floats, strings, ints, bools, datetime64`` are currently supported. For string columns, passing ``nan_rep = 'nan'`` to append will change the default nan representation on disk (which converts to/from ``np.nan``), this defaults to ``nan``."
msgstr ""

#: ../../source/user_guide/io.rst:4439
msgid "Storing MultiIndex DataFrames"
msgstr ""

#: ../../source/user_guide/io.rst:4441
msgid "Storing MultiIndex ``DataFrames`` as tables is very similar to storing/selecting from homogeneous index ``DataFrames``."
msgstr ""

#: ../../source/user_guide/io.rst:4461
msgid "The ``index`` keyword is reserved and cannot be use as a level name."
msgstr ""

#: ../../source/user_guide/io.rst:4466
#: ../../source/user_guide/io.rst:5856
msgid "Querying"
msgstr ""

#: ../../source/user_guide/io.rst:4469
msgid "Querying a table"
msgstr ""

#: ../../source/user_guide/io.rst:4471
msgid "``select`` and ``delete`` operations have an optional criterion that can be specified to select/delete only a subset of the data. This allows one to have a very large on-disk table and retrieve only a portion of the data."
msgstr ""

#: ../../source/user_guide/io.rst:4476
msgid "A query is specified using the ``Term`` class under the hood, as a boolean expression."
msgstr ""

#: ../../source/user_guide/io.rst:4478
msgid "``index`` and ``columns`` are supported indexers of ``DataFrames``."
msgstr ""

#: ../../source/user_guide/io.rst:4479
msgid "if ``data_columns`` are specified, these can be used as additional indexers."
msgstr ""

#: ../../source/user_guide/io.rst:4480
msgid "level name in a MultiIndex, with default name  ``level_0``, ``level_1``, … if not provided."
msgstr ""

#: ../../source/user_guide/io.rst:4482
msgid "Valid comparison operators are:"
msgstr ""

#: ../../source/user_guide/io.rst:4484
msgid "``=, ==, !=, >, >=, <, <=``"
msgstr ""

#: ../../source/user_guide/io.rst:4486
msgid "Valid boolean expressions are combined with:"
msgstr ""

#: ../../source/user_guide/io.rst:4488
msgid "``|`` : or"
msgstr ""

#: ../../source/user_guide/io.rst:4489
msgid "``&`` : and"
msgstr ""

#: ../../source/user_guide/io.rst:4490
msgid "``(`` and ``)`` : for grouping"
msgstr ""

#: ../../source/user_guide/io.rst:4492
msgid "These rules are similar to how boolean expressions are used in pandas for indexing."
msgstr ""

#: ../../source/user_guide/io.rst:4496
msgid "``=`` will be automatically expanded to the comparison operator ``==``"
msgstr ""

#: ../../source/user_guide/io.rst:4497
msgid "``~`` is the not operator, but can only be used in very limited circumstances"
msgstr ""

#: ../../source/user_guide/io.rst:4499
msgid "If a list/tuple of expressions is passed they will be combined via ``&``"
msgstr ""

#: ../../source/user_guide/io.rst:4501
msgid "The following are valid expressions:"
msgstr ""

#: ../../source/user_guide/io.rst:4503
msgid "``'index >= date'``"
msgstr ""

#: ../../source/user_guide/io.rst:4504
msgid "``\"columns = ['A', 'D']\"``"
msgstr ""

#: ../../source/user_guide/io.rst:4505
msgid "``\"columns in ['A', 'D']\"``"
msgstr ""

#: ../../source/user_guide/io.rst:4506
msgid "``'columns = A'``"
msgstr ""

#: ../../source/user_guide/io.rst:4507
msgid "``'columns == A'``"
msgstr ""

#: ../../source/user_guide/io.rst:4508
msgid "``\"~(columns = ['A', 'B'])\"``"
msgstr ""

#: ../../source/user_guide/io.rst:4509
msgid "``'index > df.index[3] & string = \"bar\"'``"
msgstr ""

#: ../../source/user_guide/io.rst:4510
msgid "``'(index > df.index[3] & index <= df.index[6]) | string = \"bar\"'``"
msgstr ""

#: ../../source/user_guide/io.rst:4511
msgid "``\"ts >= Timestamp('2012-02-01')\"``"
msgstr ""

#: ../../source/user_guide/io.rst:4512
msgid "``\"major_axis>=20130101\"``"
msgstr ""

#: ../../source/user_guide/io.rst:4514
msgid "The ``indexers`` are on the left-hand side of the sub-expression:"
msgstr ""

#: ../../source/user_guide/io.rst:4516
msgid "``columns``, ``major_axis``, ``ts``"
msgstr ""

#: ../../source/user_guide/io.rst:4518
msgid "The right-hand side of the sub-expression (after a comparison operator) can be:"
msgstr ""

#: ../../source/user_guide/io.rst:4520
msgid "functions that will be evaluated, e.g. ``Timestamp('2012-02-01')``"
msgstr ""

#: ../../source/user_guide/io.rst:4521
msgid "strings, e.g. ``\"bar\"``"
msgstr ""

#: ../../source/user_guide/io.rst:4522
msgid "date-like, e.g. ``20130101``, or ``\"20130101\"``"
msgstr ""

#: ../../source/user_guide/io.rst:4523
msgid "lists, e.g. ``\"['A', 'B']\"``"
msgstr ""

#: ../../source/user_guide/io.rst:4524
msgid "variables that are defined in the local names space, e.g. ``date``"
msgstr ""

#: ../../source/user_guide/io.rst:4528
msgid "Passing a string to a query by interpolating it into the query expression is not recommended. Simply assign the string of interest to a variable and use that variable in an expression. For example, do this"
msgstr ""

#: ../../source/user_guide/io.rst:4537
msgid "instead of this"
msgstr ""

#: ../../source/user_guide/io.rst:4544
msgid "The latter will **not** work and will raise a ``SyntaxError``.Note that there's a single quote followed by a double quote in the ``string`` variable."
msgstr ""

#: ../../source/user_guide/io.rst:4548
msgid "If you *must* interpolate, use the ``'%r'`` format specifier"
msgstr ""

#: ../../source/user_guide/io.rst:4554
msgid "which will quote ``string``."
msgstr ""

#: ../../source/user_guide/io.rst:4557
msgid "Here are some examples:"
msgstr ""

#: ../../source/user_guide/io.rst:4568
msgid "Use boolean expressions, with in-line function evaluation."
msgstr ""

#: ../../source/user_guide/io.rst:4574
msgid "Use inline column reference."
msgstr ""

#: ../../source/user_guide/io.rst:4580
msgid "The ``columns`` keyword can be supplied to select a list of columns to be returned, this is equivalent to passing a ``'columns=list_of_columns_to_filter'``:"
msgstr ""

#: ../../source/user_guide/io.rst:4588
msgid "``start`` and ``stop`` parameters can be specified to limit the total search space. These are in terms of the total number of rows in a table."
msgstr ""

#: ../../source/user_guide/io.rst:4593
msgid "``select`` will raise a ``ValueError`` if the query expression has an unknown variable reference. Usually this means that you are trying to select on a column that is **not** a data_column."
msgstr ""

#: ../../source/user_guide/io.rst:4597
msgid "``select`` will raise a ``SyntaxError`` if the query expression is not valid."
msgstr ""

#: ../../source/user_guide/io.rst:4603
msgid "Query timedelta64[ns]"
msgstr ""

#: ../../source/user_guide/io.rst:4605
msgid "You can store and query using the ``timedelta64[ns]`` type. Terms can be specified in the format: ``<float>(<unit>)``, where float may be signed (and fractional), and unit can be ``D,s,ms,us,ns`` for the timedelta. Here's an example:"
msgstr ""

#: ../../source/user_guide/io.rst:4630
msgid "Query MultiIndex"
msgstr ""

#: ../../source/user_guide/io.rst:4632
msgid "Selecting from a ``MultiIndex`` can be achieved by using the name of the level."
msgstr ""

#: ../../source/user_guide/io.rst:4639
msgid "If the ``MultiIndex`` levels names are ``None``, the levels are automatically made available via the ``level_n`` keyword with ``n`` the level of the ``MultiIndex`` you want to select from."
msgstr ""

#: ../../source/user_guide/io.rst:4658
msgid "Indexing"
msgstr ""

#: ../../source/user_guide/io.rst:4660
msgid "You can create/modify an index for a table with ``create_table_index`` after data is already in the table (after and ``append/put`` operation). Creating a table index is **highly** encouraged. This will speed your queries a great deal when you use a ``select`` with the indexed dimension as the ``where``."
msgstr ""

#: ../../source/user_guide/io.rst:4668
msgid "Indexes are automagically created on the indexables and any data columns you specify. This behavior can be turned off by passing ``index=False`` to ``append``."
msgstr ""

#: ../../source/user_guide/io.rst:4683
msgid "Oftentimes when appending large amounts of data to a store, it is useful to turn off index creation for each append, then recreate at the end."
msgstr ""

#: ../../source/user_guide/io.rst:4695
msgid "Then create the index when finished appending."
msgstr ""

#: ../../source/user_guide/io.rst:4710
msgid "See `here <https://stackoverflow.com/questions/17893370/ptrepack-sortby-needs-full-index>`__ for how to create a completely-sorted-index (CSI) on an existing store."
msgstr ""

#: ../../source/user_guide/io.rst:4715
msgid "Query via data columns"
msgstr ""

#: ../../source/user_guide/io.rst:4717
msgid "You can designate (and index) certain columns that you want to be able to perform queries (other than the ``indexable`` columns, which you can always query). For instance say you want to perform this common operation, on-disk, and return just the frame that matches this query. You can specify ``data_columns = True`` to force all columns to be ``data_columns``."
msgstr ""

#: ../../source/user_guide/io.rst:4748
msgid "There is some performance degradation by making lots of columns into ``data columns``, so it is up to the user to designate these. In addition, you cannot change data columns (nor indexables) after the first append/put operation (Of course you can simply read in the data and create a new table!)."
msgstr ""

#: ../../source/user_guide/io.rst:4755
msgid "Iterator"
msgstr ""

#: ../../source/user_guide/io.rst:4757
msgid "You can pass ``iterator=True`` or ``chunksize=number_in_a_chunk`` to ``select`` and ``select_as_multiple`` to return an iterator on the results. The default is 50,000 rows returned in a chunk."
msgstr ""

#: ../../source/user_guide/io.rst:4768
msgid "You can also use the iterator with ``read_hdf`` which will open, then automatically close the store when finished iterating."
msgstr ""

#: ../../source/user_guide/io.rst:4776
msgid "Note, that the chunksize keyword applies to the **source** rows. So if you are doing a query, then the chunksize will subdivide the total rows in the table and the query applied, returning an iterator on potentially unequal sized chunks."
msgstr ""

#: ../../source/user_guide/io.rst:4780
msgid "Here is a recipe for generating a query and using it to create equal sized return chunks."
msgstr ""

#: ../../source/user_guide/io.rst:4799
msgid "Advanced queries"
msgstr ""

#: ../../source/user_guide/io.rst:4802
msgid "Select a single column"
msgstr ""

#: ../../source/user_guide/io.rst:4804
msgid "To retrieve a single indexable or data column, use the method ``select_column``. This will, for example, enable you to get the index very quickly. These return a ``Series`` of the result, indexed by the row number. These do not currently accept the ``where`` selector."
msgstr ""

#: ../../source/user_guide/io.rst:4817
msgid "Selecting coordinates"
msgstr ""

#: ../../source/user_guide/io.rst:4819
msgid "Sometimes you want to get the coordinates (a.k.a the index locations) of your query. This returns an ``Index`` of the resulting locations. These coordinates can also be passed to subsequent ``where`` operations."
msgstr ""

#: ../../source/user_guide/io.rst:4836
msgid "Selecting using a where mask"
msgstr ""

#: ../../source/user_guide/io.rst:4838
msgid "Sometime your query can involve creating a list of rows to select. Usually this ``mask`` would be a resulting ``index`` from an indexing operation. This example selects the months of a datetimeindex which are 5."
msgstr ""

#: ../../source/user_guide/io.rst:4853
msgid "Storer object"
msgstr ""

#: ../../source/user_guide/io.rst:4855
msgid "If you want to inspect the stored object, retrieve via ``get_storer``. You could use this programmatically to say get the number of rows in an object."
msgstr ""

#: ../../source/user_guide/io.rst:4865
msgid "Multiple table queries"
msgstr ""

#: ../../source/user_guide/io.rst:4867
msgid "The methods ``append_to_multiple`` and ``select_as_multiple`` can perform appending/selecting from multiple tables at once. The idea is to have one table (call it the selector table) that you index most/all of the columns, and perform your queries. The other table(s) are data tables with an index matching the selector table's index. You can then perform a very fast query on the selector table, yet get lots of data back. This method is similar to having a very wide table, but enables more efficient queries."
msgstr ""

#: ../../source/user_guide/io.rst:4876
msgid "The ``append_to_multiple`` method splits a given single DataFrame into multiple tables according to ``d``, a dictionary that maps the table names to a list of 'columns' you want in that table. If ``None`` is used in place of a list, that table will have the remaining unspecified columns of the given DataFrame. The argument ``selector`` defines which table is the selector table (which you can make queries from). The argument ``dropna`` will drop rows from the input ``DataFrame`` to ensure tables are synchronized.  This means that if a row for one of the tables being written to is entirely ``np.nan``, that row will be dropped from all tables."
msgstr ""

#: ../../source/user_guide/io.rst:4886
msgid "If ``dropna`` is False, **THE USER IS RESPONSIBLE FOR SYNCHRONIZING THE TABLES**. Remember that entirely ``np.Nan`` rows are not written to the HDFStore, so if you choose to call ``dropna=False``, some tables may have more rows than others, and therefore ``select_as_multiple`` may not work or it may return unexpected results."
msgstr ""

#: ../../source/user_guide/io.rst:4921
msgid "Delete from a table"
msgstr ""

#: ../../source/user_guide/io.rst:4923
msgid "You can delete from a table selectively by specifying a ``where``. In deleting rows, it is important to understand the ``PyTables`` deletes rows by erasing the rows, then **moving** the following data. Thus deleting can potentially be a very expensive operation depending on the orientation of your data. To get optimal performance, it's worthwhile to have the dimension you are deleting be the first of the ``indexables``."
msgstr ""

#: ../../source/user_guide/io.rst:4931
msgid "Data is ordered (on the disk) in terms of the ``indexables``. Here's a simple use case. You store panel-type data, with dates in the ``major_axis`` and ids in the ``minor_axis``. The data is then interleaved like this:"
msgstr ""

#: ../../source/user_guide/io.rst:4939
msgid "date_1"
msgstr ""

#: ../../source/user_guide/io.rst:4937
#: ../../source/user_guide/io.rst:4942
msgid "id_1"
msgstr ""

#: ../../source/user_guide/io.rst:4938
msgid "id_2"
msgstr ""

#: ../../source/user_guide/io.rst:4939
#: ../../source/user_guide/io.rst:4943
msgid "."
msgstr ""

#: ../../source/user_guide/io.rst:4940
#: ../../source/user_guide/io.rst:4944
msgid "id_n"
msgstr ""

#: ../../source/user_guide/io.rst:4944
msgid "date_2"
msgstr ""

#: ../../source/user_guide/io.rst:4946
msgid "It should be clear that a delete operation on the ``major_axis`` will be fairly quick, as one chunk is removed, then the following data moved. On the other hand a delete operation on the ``minor_axis`` will be very expensive. In this case it would almost certainly be faster to rewrite the table using a ``where`` that selects all but the missing data."
msgstr ""

#: ../../source/user_guide/io.rst:4954
msgid "Please note that HDF5 **DOES NOT RECLAIM SPACE** in the h5 files automatically. Thus, repeatedly deleting (or removing nodes) and adding again, **WILL TEND TO INCREASE THE FILE SIZE**."
msgstr ""

#: ../../source/user_guide/io.rst:4958
msgid "To *repack and clean* the file, use :ref:`ptrepack <io.hdf5-ptrepack>`."
msgstr ""

#: ../../source/user_guide/io.rst:4963
msgid "Notes & caveats"
msgstr ""

#: ../../source/user_guide/io.rst:4967
msgid "Compression"
msgstr ""

#: ../../source/user_guide/io.rst:4969
msgid "``PyTables`` allows the stored data to be compressed. This applies to all kinds of stores, not just tables. Two parameters are used to control compression: ``complevel`` and ``complib``."
msgstr ""

#: ../../source/user_guide/io.rst:4973
msgid "``complevel`` specifies if and how hard data is to be compressed. ``complevel=0`` and ``complevel=None`` disables compression and ``0<complevel<10`` enables compression."
msgstr ""

#: ../../source/user_guide/io.rst:4977
msgid "``complib`` specifies which compression library to use. If nothing is  specified the default library ``zlib`` is used. A compression library usually optimizes for either good compression rates or speed and the results will depend on the type of data. Which type of compression to choose depends on your specific needs and data. The list of supported compression libraries:"
msgstr ""

#: ../../source/user_guide/io.rst:4984
msgid "`zlib <https://zlib.net/>`_: The default compression library. A classic in terms of compression, achieves good compression rates but is somewhat slow."
msgstr ""

#: ../../source/user_guide/io.rst:4987
msgid "`lzo <https://www.oberhumer.com/opensource/lzo/>`_: Fast compression and decompression."
msgstr ""

#: ../../source/user_guide/io.rst:4989
msgid "`bzip2 <https://sourceware.org/bzip2/>`_: Good compression rates."
msgstr ""

#: ../../source/user_guide/io.rst:4990
msgid "`blosc <https://www.blosc.org/>`_: Fast compression and decompression."
msgstr ""

#: ../../source/user_guide/io.rst:4993
msgid "Support for alternative blosc compressors:"
msgstr ""

#: ../../source/user_guide/io.rst:4995
msgid "`blosc:blosclz <https://www.blosc.org/>`_ This is the default compressor for ``blosc``"
msgstr ""

#: ../../source/user_guide/io.rst:4997
msgid "`blosc:lz4 <https://fastcompression.blogspot.com/p/lz4.html>`_: A compact, very popular and fast compressor."
msgstr ""

#: ../../source/user_guide/io.rst:5000
msgid "`blosc:lz4hc <https://fastcompression.blogspot.com/p/lz4.html>`_: A tweaked version of LZ4, produces better compression ratios at the expense of speed."
msgstr ""

#: ../../source/user_guide/io.rst:5004
msgid "`blosc:snappy <https://google.github.io/snappy/>`_: A popular compressor used in many places."
msgstr ""

#: ../../source/user_guide/io.rst:5006
msgid "`blosc:zlib <https://zlib.net/>`_: A classic; somewhat slower than the previous ones, but achieving better compression ratios."
msgstr ""

#: ../../source/user_guide/io.rst:5009
msgid "`blosc:zstd <https://facebook.github.io/zstd/>`_: An extremely well balanced codec; it provides the best compression ratios among the others above, and at reasonably fast speed."
msgstr ""

#: ../../source/user_guide/io.rst:5014
msgid "If ``complib`` is defined as something other than the listed libraries a ``ValueError`` exception is issued."
msgstr ""

#: ../../source/user_guide/io.rst:5019
msgid "If the library specified with the ``complib`` option is missing on your platform, compression defaults to ``zlib`` without further ado."
msgstr ""

#: ../../source/user_guide/io.rst:5022
msgid "Enable compression for all objects within the file:"
msgstr ""

#: ../../source/user_guide/io.rst:5030
msgid "Or on-the-fly compression (this only applies to tables) in stores where compression is not enabled:"
msgstr ""

#: ../../source/user_guide/io.rst:5039
msgid "ptrepack"
msgstr ""

#: ../../source/user_guide/io.rst:5041
msgid "``PyTables`` offers better write performance when tables are compressed after they are written, as opposed to turning on compression at the very beginning. You can use the supplied ``PyTables`` utility ``ptrepack``. In addition, ``ptrepack`` can change compression levels after the fact."
msgstr ""

#: ../../source/user_guide/io.rst:5051
msgid "Furthermore ``ptrepack in.h5 out.h5`` will *repack* the file to allow you to reuse previously deleted space. Alternatively, one can simply remove the file and write again, or use the ``copy`` method."
msgstr ""

#: ../../source/user_guide/io.rst:5058
msgid "Caveats"
msgstr ""

#: ../../source/user_guide/io.rst:5062
msgid "``HDFStore`` is **not-threadsafe for writing**. The underlying ``PyTables`` only supports concurrent reads (via threading or processes). If you need reading and writing *at the same time*, you need to serialize these operations in a single thread in a single process. You will corrupt your data otherwise. See the (:issue:`2397`) for more information."
msgstr ""

#: ../../source/user_guide/io.rst:5068
msgid "If you use locks to manage write access between multiple processes, you may want to use :py:func:`~os.fsync` before releasing write locks. For convenience you can use ``store.flush(fsync=True)`` to do this for you."
msgstr ""

#: ../../source/user_guide/io.rst:5071
msgid "Once a ``table`` is created columns (DataFrame) are fixed; only exactly the same columns can be appended"
msgstr ""

#: ../../source/user_guide/io.rst:5073
msgid "Be aware that timezones (e.g., ``pytz.timezone('US/Eastern')``) are not necessarily equal across timezone versions.  So if data is localized to a specific timezone in the HDFStore using one version of a timezone library and that data is updated with another version, the data will be converted to UTC since these timezones are not considered equal.  Either use the same version of timezone library or use ``tz_convert`` with the updated timezone definition."
msgstr ""

#: ../../source/user_guide/io.rst:5083
msgid "``PyTables`` will show a ``NaturalNameWarning`` if a column name cannot be used as an attribute selector. *Natural* identifiers contain only letters, numbers, and underscores, and may not begin with a number. Other identifiers cannot be used in a ``where`` clause and are generally a bad idea."
msgstr ""

#: ../../source/user_guide/io.rst:5093
msgid "DataTypes"
msgstr ""

#: ../../source/user_guide/io.rst:5095
msgid "``HDFStore`` will map an object dtype to the ``PyTables`` underlying dtype. This means the following types are known to work:"
msgstr ""

#: ../../source/user_guide/io.rst:5099
msgid "Type"
msgstr ""

#: ../../source/user_guide/io.rst:5099
msgid "Represents missing values"
msgstr ""

#: ../../source/user_guide/io.rst:5101
msgid "floating : ``float64, float32, float16``"
msgstr ""

#: ../../source/user_guide/io.rst:5101
#: ../../source/user_guide/io.rst:5107
msgid "``np.nan``"
msgstr ""

#: ../../source/user_guide/io.rst:5102
msgid "integer : ``int64, int32, int8, uint64,uint32, uint8``"
msgstr ""

#: ../../source/user_guide/io.rst:5104
msgid "``datetime64[ns]``"
msgstr ""

#: ../../source/user_guide/io.rst:5104
#: ../../source/user_guide/io.rst:5105
msgid "``NaT``"
msgstr ""

#: ../../source/user_guide/io.rst:5105
msgid "``timedelta64[ns]``"
msgstr ""

#: ../../source/user_guide/io.rst:5106
msgid "categorical : see the section below"
msgstr ""

#: ../../source/user_guide/io.rst:5107
msgid "object : ``strings``"
msgstr ""

#: ../../source/user_guide/io.rst:5110
msgid "``unicode`` columns are not supported, and **WILL FAIL**."
msgstr ""

#: ../../source/user_guide/io.rst:5115
#: ../../source/user_guide/io.rst:6124
msgid "Categorical data"
msgstr ""

#: ../../source/user_guide/io.rst:5117
msgid "You can write data that contains ``category`` dtypes to a ``HDFStore``. Queries work the same as if it was an object array. However, the ``category`` dtyped data is stored in a more efficient manner."
msgstr ""

#: ../../source/user_guide/io.rst:5143
msgid "String columns"
msgstr ""

#: ../../source/user_guide/io.rst:5145
msgid "**min_itemsize**"
msgstr ""

#: ../../source/user_guide/io.rst:5147
msgid "The underlying implementation of ``HDFStore`` uses a fixed column width (itemsize) for string columns. A string column itemsize is calculated as the maximum of the length of data (for that column) that is passed to the ``HDFStore``, **in the first append**. Subsequent appends, may introduce a string for a column **larger** than the column can hold, an Exception will be raised (otherwise you could have a silent truncation of these columns, leading to loss of information). In the future we may relax this and allow a user-specified truncation to occur."
msgstr ""

#: ../../source/user_guide/io.rst:5154
msgid "Pass ``min_itemsize`` on the first table creation to a-priori specify the minimum length of a particular string column. ``min_itemsize`` can be an integer, or a dict mapping a column name to an integer. You can pass ``values`` as a key to allow all *indexables* or *data_columns* to have this min_itemsize."
msgstr ""

#: ../../source/user_guide/io.rst:5158
msgid "Passing a ``min_itemsize`` dict will cause all passed columns to be created as *data_columns* automatically."
msgstr ""

#: ../../source/user_guide/io.rst:5162
msgid "If you are not passing any ``data_columns``, then the ``min_itemsize`` will be the maximum of the length of any string passed"
msgstr ""

#: ../../source/user_guide/io.rst:5178
msgid "**nan_rep**"
msgstr ""

#: ../../source/user_guide/io.rst:5180
msgid "String columns will serialize a ``np.nan`` (a missing value) with the ``nan_rep`` string representation. This defaults to the string value ``nan``. You could inadvertently turn an actual ``nan`` value into a missing value."
msgstr ""

#: ../../source/user_guide/io.rst:5197
msgid "Performance"
msgstr ""

#: ../../source/user_guide/io.rst:5199
msgid "``tables`` format come with a writing performance penalty as compared to ``fixed`` stores. The benefit is the ability to append/delete and query (potentially very large amounts of data).  Write times are generally longer as compared with regular stores. Query times can be quite fast, especially on an indexed axis."
msgstr ""

#: ../../source/user_guide/io.rst:5204
msgid "You can pass ``chunksize=<int>`` to ``append``, specifying the write chunksize (default is 50000). This will significantly lower your memory usage on writing."
msgstr ""

#: ../../source/user_guide/io.rst:5207
msgid "You can pass ``expectedrows=<int>`` to the first ``append``, to set the TOTAL number of rows that ``PyTables`` will expect. This will optimize read/write performance."
msgstr ""

#: ../../source/user_guide/io.rst:5210
msgid "Duplicate rows can be written to tables, but are filtered out in selection (with the last items being selected; thus a table is unique on major, minor pairs)"
msgstr ""

#: ../../source/user_guide/io.rst:5213
msgid "A ``PerformanceWarning`` will be raised if you are attempting to store types that will be pickled by PyTables (rather than stored as endemic types). See `Here <https://stackoverflow.com/questions/14355151/how-to-make-pandas-hdfstore-put-operation-faster/14370190#14370190>`__ for more information and some solutions."
msgstr ""

#: ../../source/user_guide/io.rst:5230
msgid "Feather"
msgstr ""

#: ../../source/user_guide/io.rst:5232
msgid "Feather provides binary columnar serialization for data frames. It is designed to make reading and writing data frames efficient, and to make sharing data across data analysis languages easy."
msgstr ""

#: ../../source/user_guide/io.rst:5235
msgid "Feather is designed to faithfully serialize and de-serialize DataFrames, supporting all of the pandas dtypes, including extension dtypes such as categorical and datetime with tz."
msgstr ""

#: ../../source/user_guide/io.rst:5238
msgid "Several caveats:"
msgstr ""

#: ../../source/user_guide/io.rst:5240
msgid "The format will NOT write an ``Index``, or ``MultiIndex`` for the ``DataFrame`` and will raise an error if a non-default one is provided. You can ``.reset_index()`` to store the index or ``.reset_index(drop=True)`` to ignore it."
msgstr ""

#: ../../source/user_guide/io.rst:5244
msgid "Duplicate column names and non-string columns names are not supported"
msgstr ""

#: ../../source/user_guide/io.rst:5245
msgid "Actual Python objects in object dtype columns are not supported. These will raise a helpful error message on an attempt at serialization."
msgstr ""

#: ../../source/user_guide/io.rst:5248
msgid "See the `Full Documentation <https://github.com/wesm/feather>`__."
msgstr ""

#: ../../source/user_guide/io.rst:5269
msgid "Write to a feather file."
msgstr ""

#: ../../source/user_guide/io.rst:5276
msgid "Read from a feather file."
msgstr ""

#: ../../source/user_guide/io.rst:5296
msgid "Parquet"
msgstr ""

#: ../../source/user_guide/io.rst:5298
msgid "`Apache Parquet <https://parquet.apache.org/>`__ provides a partitioned binary columnar serialization for data frames. It is designed to make reading and writing data frames efficient, and to make sharing data across data analysis languages easy. Parquet can use a variety of compression techniques to shrink the file size as much as possible while still maintaining good read performance."
msgstr ""

#: ../../source/user_guide/io.rst:5303
msgid "Parquet is designed to faithfully serialize and de-serialize ``DataFrame`` s, supporting all of the pandas dtypes, including extension dtypes such as datetime with tz."
msgstr ""

#: ../../source/user_guide/io.rst:5306
msgid "Several caveats."
msgstr ""

#: ../../source/user_guide/io.rst:5308
msgid "Duplicate column names and non-string columns names are not supported."
msgstr ""

#: ../../source/user_guide/io.rst:5309
msgid "The ``pyarrow`` engine always writes the index to the output, but ``fastparquet`` only writes non-default indexes. This extra column can cause problems for non-pandas consumers that are not expecting it. You can force including or omitting indexes with the ``index`` argument, regardless of the underlying engine."
msgstr ""

#: ../../source/user_guide/io.rst:5312
msgid "Index level names, if specified, must be strings."
msgstr ""

#: ../../source/user_guide/io.rst:5313
msgid "In the ``pyarrow`` engine, categorical dtypes for non-string types can be serialized to parquet, but will de-serialize as their primitive dtype."
msgstr ""

#: ../../source/user_guide/io.rst:5314
msgid "The ``pyarrow`` engine preserves the ``ordered`` flag of categorical dtypes with string types. ``fastparquet`` does not preserve the ``ordered`` flag."
msgstr ""

#: ../../source/user_guide/io.rst:5315
msgid "Non supported types include ``Interval`` and actual Python object types. These will raise a helpful error message on an attempt at serialization. ``Period`` type is supported with pyarrow >= 0.16.0."
msgstr ""

#: ../../source/user_guide/io.rst:5317
msgid "The ``pyarrow`` engine preserves extension data types such as the nullable integer and string data type (requiring pyarrow >= 0.16.0, and requiring the extension type to implement the needed protocols, see the :ref:`extension types documentation <extending.extension.arrow>`)."
msgstr ""

#: ../../source/user_guide/io.rst:5321
msgid "You can specify an ``engine`` to direct the serialization. This can be one of ``pyarrow``, or ``fastparquet``, or ``auto``. If the engine is NOT specified, then the ``pd.options.io.parquet.engine`` option is checked; if this is also ``auto``, then ``pyarrow`` is tried, and falling back to ``fastparquet``."
msgstr ""

#: ../../source/user_guide/io.rst:5325
msgid "See the documentation for `pyarrow <https://arrow.apache.org/docs/python/>`__ and `fastparquet <https://fastparquet.readthedocs.io/en/latest/>`__."
msgstr ""

#: ../../source/user_guide/io.rst:5329
msgid "These engines are very similar and should read/write nearly identical parquet format files. ``pyarrow>=8.0.0`` supports timedelta data, ``fastparquet>=0.1.4`` supports timezone aware datetimes. These libraries differ by having different underlying dependencies (``fastparquet`` by using ``numba``, while ``pyarrow`` uses a c-library)."
msgstr ""

#: ../../source/user_guide/io.rst:5352
msgid "Write to a parquet file."
msgstr ""

#: ../../source/user_guide/io.rst:5360
msgid "Read from a parquet file."
msgstr ""

#: ../../source/user_guide/io.rst:5381
msgid "Note that this is not supported for ``fastparquet``."
msgstr ""

#: ../../source/user_guide/io.rst:5384
msgid "Read only certain columns of a parquet file."
msgstr ""

#: ../../source/user_guide/io.rst:5410
msgid "Handling indexes"
msgstr ""

#: ../../source/user_guide/io.rst:5412
msgid "Serializing a ``DataFrame`` to parquet may include the implicit index as one or more columns in the output file. Thus, this code:"
msgstr ""

#: ../../source/user_guide/io.rst:5421
msgid "creates a parquet file with *three* columns if you use ``pyarrow`` for serialization: ``a``, ``b``, and ``__index_level_0__``. If you're using ``fastparquet``, the index `may or may not <https://fastparquet.readthedocs.io/en/latest/api.html#fastparquet.write>`_ be written to the file."
msgstr ""

#: ../../source/user_guide/io.rst:5426
msgid "This unexpected extra column causes some databases like Amazon Redshift to reject the file, because that column doesn't exist in the target table."
msgstr ""

#: ../../source/user_guide/io.rst:5429
msgid "If you want to omit a dataframe's indexes when writing, pass ``index=False`` to :func:`~pandas.DataFrame.to_parquet`:"
msgstr ""

#: ../../source/user_guide/io.rst:5437
msgid "This creates a parquet file with just the two expected columns, ``a`` and ``b``. If your ``DataFrame`` has a custom index, you won't get it back when you load this file into a ``DataFrame``."
msgstr ""

#: ../../source/user_guide/io.rst:5441
msgid "Passing ``index=True`` will *always* write the index, even if that's not the underlying engine's default behavior."
msgstr ""

#: ../../source/user_guide/io.rst:5451
msgid "Partitioning Parquet files"
msgstr ""

#: ../../source/user_guide/io.rst:5453
msgid "Parquet supports partitioning of data based on the values of one or more columns."
msgstr ""

#: ../../source/user_guide/io.rst:5461
msgid "The ``path`` specifies the parent directory to which data will be saved. The ``partition_cols`` are the column names by which the dataset will be partitioned. Columns are partitioned in the order they are given. The partition splits are determined by the unique values in the partition columns. The above example creates a partitioned dataset that may look like:"
msgstr ""

#: ../../source/user_guide/io.rst:5490
msgid "ORC"
msgstr ""

#: ../../source/user_guide/io.rst:5492
msgid "Similar to the :ref:`parquet <io.parquet>` format, the `ORC Format <https://orc.apache.org/>`__ is a binary columnar serialization for data frames. It is designed to make reading data frames efficient. pandas provides both the reader and the writer for the ORC format, :func:`~pandas.read_orc` and :func:`~pandas.DataFrame.to_orc`. This requires the `pyarrow <https://arrow.apache.org/docs/python/>`__ library."
msgstr ""

#: ../../source/user_guide/io.rst:5498
msgid "It is *highly recommended* to install pyarrow using conda due to some issues occurred by pyarrow."
msgstr ""

#: ../../source/user_guide/io.rst:5499
msgid ":func:`~pandas.DataFrame.to_orc` requires pyarrow>=7.0.0."
msgstr ""

#: ../../source/user_guide/io.rst:5500
msgid ":func:`~pandas.read_orc` and :func:`~pandas.DataFrame.to_orc` are not supported on Windows yet, you can find valid environments on :ref:`install optional dependencies <install.warn_orc>`."
msgstr ""

#: ../../source/user_guide/io.rst:5501
msgid "For supported dtypes please refer to `supported ORC features in Arrow <https://arrow.apache.org/docs/cpp/orc.html#data-types>`__."
msgstr ""

#: ../../source/user_guide/io.rst:5502
msgid "Currently timezones in datetime columns are not preserved when a dataframe is converted into ORC files."
msgstr ""

#: ../../source/user_guide/io.rst:5519
msgid "Write to an orc file."
msgstr ""

#: ../../source/user_guide/io.rst:5526
msgid "Read from an orc file."
msgstr ""

#: ../../source/user_guide/io.rst:5535
msgid "Read only certain columns of an orc file."
msgstr ""

#: ../../source/user_guide/io.rst:5555
msgid "SQL queries"
msgstr ""

#: ../../source/user_guide/io.rst:5557
msgid "The :mod:`pandas.io.sql` module provides a collection of query wrappers to both facilitate data retrieval and to reduce dependency on DB-specific API. Database abstraction is provided by SQLAlchemy if installed. In addition you will need a driver library for your database. Examples of such drivers are `psycopg2 <https://www.psycopg.org/>`__ for PostgreSQL or `pymysql <https://github.com/PyMySQL/PyMySQL>`__ for MySQL. For `SQLite <https://docs.python.org/3/library/sqlite3.html>`__ this is included in Python's standard library by default. You can find an overview of supported drivers for each SQL dialect in the `SQLAlchemy docs <https://docs.sqlalchemy.org/en/latest/dialects/index.html>`__."
msgstr ""

#: ../../source/user_guide/io.rst:5567
msgid "If SQLAlchemy is not installed, you can use a :class:`sqlite3.Connection` in place of a SQLAlchemy engine, connection, or URI string."
msgstr ""

#: ../../source/user_guide/io.rst:5570
msgid "See also some :ref:`cookbook examples <cookbook.sql>` for some advanced strategies."
msgstr ""

#: ../../source/user_guide/io.rst:5572
msgid "The key functions are:"
msgstr ""

#: ../../source/user_guide/io.rst:5580:<autosummary>:1
msgid ":py:obj:`read_sql_table <pandas.read_sql_table>`\\ \\(table\\_name\\, con\\[\\, schema\\, ...\\]\\)"
msgstr ""

#: ../../source/user_guide/io.rst:5580:<autosummary>:1
msgid "Read SQL database table into a DataFrame."
msgstr ""

#: ../../source/user_guide/io.rst:5580:<autosummary>:1
msgid ":py:obj:`read_sql_query <pandas.read_sql_query>`\\ \\(sql\\, con\\[\\, index\\_col\\, ...\\]\\)"
msgstr ""

#: ../../source/user_guide/io.rst:5580:<autosummary>:1
msgid "Read SQL query into a DataFrame."
msgstr ""

#: ../../source/user_guide/io.rst:5580:<autosummary>:1
msgid ":py:obj:`read_sql <pandas.read_sql>`\\ \\(sql\\, con\\[\\, index\\_col\\, ...\\]\\)"
msgstr ""

#: ../../source/user_guide/io.rst:5580:<autosummary>:1
msgid "Read SQL query or database table into a DataFrame."
msgstr ""

#: ../../source/user_guide/io.rst:5580:<autosummary>:1
msgid ":py:obj:`DataFrame.to_sql <pandas.DataFrame.to_sql>`\\ \\(name\\, con\\, \\*\\[\\, schema\\, ...\\]\\)"
msgstr ""

#: ../../source/user_guide/io.rst:5580:<autosummary>:1
msgid "Write records stored in a DataFrame to a SQL database."
msgstr ""

#: ../../source/user_guide/io.rst:5583
msgid "The function :func:`~pandas.read_sql` is a convenience wrapper around :func:`~pandas.read_sql_table` and :func:`~pandas.read_sql_query` (and for backward compatibility) and will delegate to specific function depending on the provided input (database table name or sql query). Table names do not need to be quoted if they have special characters."
msgstr ""

#: ../../source/user_guide/io.rst:5589
msgid "In the following example, we use the `SQlite <https://www.sqlite.org/index.html>`__ SQL database engine. You can use a temporary SQLite database where data are stored in \"memory\"."
msgstr ""

#: ../../source/user_guide/io.rst:5593
msgid "To connect with SQLAlchemy you use the :func:`create_engine` function to create an engine object from database URI. You only need to create the engine once per database you are connecting to. For more information on :func:`create_engine` and the URI formatting, see the examples below and the SQLAlchemy `documentation <https://docs.sqlalchemy.org/en/latest/core/engines.html>`__"
msgstr ""

#: ../../source/user_guide/io.rst:5606
msgid "If you want to manage your own connections you can pass one of those instead. The example below opens a connection to the database using a Python context manager that automatically closes the connection after the block has completed. See the `SQLAlchemy docs <https://docs.sqlalchemy.org/en/latest/core/connections.html#basic-usage>`__ for an explanation of how the database connection is handled."
msgstr ""

#: ../../source/user_guide/io.rst:5619
msgid "When you open a connection to a database you are also responsible for closing it. Side effects of leaving a connection open may include locking the database or other breaking behaviour."
msgstr ""

#: ../../source/user_guide/io.rst:5624
msgid "Writing DataFrames"
msgstr ""

#: ../../source/user_guide/io.rst:5626
msgid "Assuming the following data is in a ``DataFrame`` ``data``, we can insert it into the database using :func:`~pandas.DataFrame.to_sql`."
msgstr ""

#: ../../source/user_guide/io.rst:5630
msgid "id"
msgstr ""

#: ../../source/user_guide/io.rst:5630
msgid "Date"
msgstr ""

#: ../../source/user_guide/io.rst:5630
msgid "Col_1"
msgstr ""

#: ../../source/user_guide/io.rst:5630
msgid "Col_2"
msgstr ""

#: ../../source/user_guide/io.rst:5630
msgid "Col_3"
msgstr ""

#: ../../source/user_guide/io.rst:5632
msgid "26"
msgstr ""

#: ../../source/user_guide/io.rst:5632
msgid "2012-10-18"
msgstr ""

#: ../../source/user_guide/io.rst:5632
msgid "X"
msgstr ""

#: ../../source/user_guide/io.rst:5632
msgid "25.7"
msgstr ""

#: ../../source/user_guide/io.rst:5632
#: ../../source/user_guide/io.rst:5636
msgid "True"
msgstr ""

#: ../../source/user_guide/io.rst:5634
msgid "42"
msgstr ""

#: ../../source/user_guide/io.rst:5634
msgid "2012-10-19"
msgstr ""

#: ../../source/user_guide/io.rst:5634
msgid "Y"
msgstr ""

#: ../../source/user_guide/io.rst:5634
msgid "-12.4"
msgstr ""

#: ../../source/user_guide/io.rst:5634
msgid "False"
msgstr ""

#: ../../source/user_guide/io.rst:5636
msgid "63"
msgstr ""

#: ../../source/user_guide/io.rst:5636
msgid "2012-10-20"
msgstr ""

#: ../../source/user_guide/io.rst:5636
msgid "Z"
msgstr ""

#: ../../source/user_guide/io.rst:5636
msgid "5.73"
msgstr ""

#: ../../source/user_guide/io.rst:5656
msgid "With some databases, writing large DataFrames can result in errors due to packet size limitations being exceeded. This can be avoided by setting the ``chunksize`` parameter when calling ``to_sql``.  For example, the following writes ``data`` to the database in batches of 1000 rows at a time:"
msgstr ""

#: ../../source/user_guide/io.rst:5666
msgid "SQL data types"
msgstr ""

#: ../../source/user_guide/io.rst:5668
msgid ":func:`~pandas.DataFrame.to_sql` will try to map your data to an appropriate SQL data type based on the dtype of the data. When you have columns of dtype ``object``, pandas will try to infer the data type."
msgstr ""

#: ../../source/user_guide/io.rst:5672
msgid "You can always override the default type by specifying the desired SQL type of any of the columns by using the ``dtype`` argument. This argument needs a dictionary mapping column names to SQLAlchemy types (or strings for the sqlite3 fallback mode). For example, specifying to use the sqlalchemy ``String`` type instead of the default ``Text`` type for string columns:"
msgstr ""

#: ../../source/user_guide/io.rst:5687
msgid "Due to the limited support for timedelta's in the different database flavors, columns with type ``timedelta64`` will be written as integer values as nanoseconds to the database and a warning will be raised."
msgstr ""

#: ../../source/user_guide/io.rst:5693
msgid "Columns of ``category`` dtype will be converted to the dense representation as you would get with ``np.asarray(categorical)`` (e.g. for string categories this gives an array of strings). Because of this, reading the database table back in does **not** generate a categorical."
msgstr ""

#: ../../source/user_guide/io.rst:5702
msgid "Datetime data types"
msgstr ""

#: ../../source/user_guide/io.rst:5704
msgid "Using SQLAlchemy, :func:`~pandas.DataFrame.to_sql` is capable of writing datetime data that is timezone naive or timezone aware. However, the resulting data stored in the database ultimately depends on the supported data type for datetime data of the database system being used."
msgstr ""

#: ../../source/user_guide/io.rst:5709
msgid "The following table lists supported data types for datetime data for some common databases. Other database dialects may have different data types for datetime data."
msgstr ""

#: ../../source/user_guide/io.rst:5714
msgid "Database"
msgstr ""

#: ../../source/user_guide/io.rst:5714
msgid "SQL Datetime Types"
msgstr ""

#: ../../source/user_guide/io.rst:5714
msgid "Timezone Support"
msgstr ""

#: ../../source/user_guide/io.rst:5716
msgid "SQLite"
msgstr ""

#: ../../source/user_guide/io.rst:5716
msgid "``TEXT``"
msgstr ""

#: ../../source/user_guide/io.rst:5716
#: ../../source/user_guide/io.rst:5717
msgid "No"
msgstr ""

#: ../../source/user_guide/io.rst:5717
msgid "MySQL"
msgstr ""

#: ../../source/user_guide/io.rst:5717
msgid "``TIMESTAMP`` or ``DATETIME``"
msgstr ""

#: ../../source/user_guide/io.rst:5718
msgid "PostgreSQL"
msgstr ""

#: ../../source/user_guide/io.rst:5718
msgid "``TIMESTAMP`` or ``TIMESTAMP WITH TIME ZONE``"
msgstr ""

#: ../../source/user_guide/io.rst:5718
msgid "Yes"
msgstr ""

#: ../../source/user_guide/io.rst:5721
msgid "When writing timezone aware data to databases that do not support timezones, the data will be written as timezone naive timestamps that are in local time with respect to the timezone."
msgstr ""

#: ../../source/user_guide/io.rst:5725
msgid ":func:`~pandas.read_sql_table` is also capable of reading datetime data that is timezone aware or naive. When reading ``TIMESTAMP WITH TIME ZONE`` types, pandas will convert the data to UTC."
msgstr ""

#: ../../source/user_guide/io.rst:5732
msgid "Insertion method"
msgstr ""

#: ../../source/user_guide/io.rst:5734
msgid "The parameter ``method`` controls the SQL insertion clause used. Possible values are:"
msgstr ""

#: ../../source/user_guide/io.rst:5737
msgid "``None``: Uses standard SQL ``INSERT`` clause (one per row)."
msgstr ""

#: ../../source/user_guide/io.rst:5738
msgid "``'multi'``: Pass multiple values in a single ``INSERT`` clause. It uses a *special* SQL syntax not supported by all backends. This usually provides better performance for analytic databases like *Presto* and *Redshift*, but has worse performance for traditional SQL backend if the table contains many columns. For more information check the SQLAlchemy `documentation <https://docs.sqlalchemy.org/en/latest/core/dml.html#sqlalchemy.sql.expression.Insert.values.params.*args>`__."
msgstr ""

#: ../../source/user_guide/io.rst:5745
msgid "callable with signature ``(pd_table, conn, keys, data_iter)``: This can be used to implement a more performant insertion method based on specific backend dialect features."
msgstr ""

#: ../../source/user_guide/io.rst:5749
msgid "Example of a callable using PostgreSQL `COPY clause <https://www.postgresql.org/docs/current/sql-copy.html>`__::"
msgstr ""

#: ../../source/user_guide/io.rst:5787
msgid "Reading tables"
msgstr ""

#: ../../source/user_guide/io.rst:5789
msgid ":func:`~pandas.read_sql_table` will read a database table given the table name and optionally a subset of columns to read."
msgstr ""

#: ../../source/user_guide/io.rst:5794
msgid "In order to use :func:`~pandas.read_sql_table`, you **must** have the SQLAlchemy optional dependency installed."
msgstr ""

#: ../../source/user_guide/io.rst:5803
msgid "Note that pandas infers column dtypes from query outputs, and not by looking up data types in the physical database schema. For example, assume ``userid`` is an integer column in a table. Then, intuitively, ``select userid ...`` will return integer-valued series, while ``select cast(userid as text) ...`` will return object-valued (str) series. Accordingly, if the query output is empty, then all resulting columns will be returned as object-valued (since they are most general). If you foresee that your query will sometimes generate an empty result, you may want to explicitly typecast afterwards to ensure dtype integrity."
msgstr ""

#: ../../source/user_guide/io.rst:5813
msgid "You can also specify the name of the column as the ``DataFrame`` index, and specify a subset of columns to be read."
msgstr ""

#: ../../source/user_guide/io.rst:5821
msgid "And you can explicitly force columns to be parsed as dates:"
msgstr ""

#: ../../source/user_guide/io.rst:5827
msgid "If needed you can explicitly specify a format string, or a dict of arguments to pass to :func:`pandas.to_datetime`:"
msgstr ""

#: ../../source/user_guide/io.rst:5840
msgid "You can check if a table exists using :func:`~pandas.io.sql.has_table`"
msgstr ""

#: ../../source/user_guide/io.rst:5843
msgid "Schema support"
msgstr ""

#: ../../source/user_guide/io.rst:5845
msgid "Reading from and writing to different schema's is supported through the ``schema`` keyword in the :func:`~pandas.read_sql_table` and :func:`~pandas.DataFrame.to_sql` functions. Note however that this depends on the database flavor (sqlite does not have schema's). For example:"
msgstr ""

#: ../../source/user_guide/io.rst:5858
msgid "You can query using raw SQL in the :func:`~pandas.read_sql_query` function. In this case you must use the SQL variant appropriate for your database. When using SQLAlchemy, you can also pass SQLAlchemy Expression language constructs, which are database-agnostic."
msgstr ""

#: ../../source/user_guide/io.rst:5867
msgid "Of course, you can specify a more \"complex\" query."
msgstr ""

#: ../../source/user_guide/io.rst:5873
msgid "The :func:`~pandas.read_sql_query` function supports a ``chunksize`` argument. Specifying this will return an iterator through chunks of the query result:"
msgstr ""

#: ../../source/user_guide/io.rst:5888
msgid "Engine connection examples"
msgstr ""

#: ../../source/user_guide/io.rst:5890
msgid "To connect with SQLAlchemy you use the :func:`create_engine` function to create an engine object from database URI. You only need to create the engine once per database you are connecting to."
msgstr ""

#: ../../source/user_guide/io.rst:5913
msgid "For more information see the examples the SQLAlchemy `documentation <https://docs.sqlalchemy.org/en/latest/core/engines.html>`__"
msgstr ""

#: ../../source/user_guide/io.rst:5917
msgid "Advanced SQLAlchemy queries"
msgstr ""

#: ../../source/user_guide/io.rst:5919
msgid "You can use SQLAlchemy constructs to describe your query."
msgstr ""

#: ../../source/user_guide/io.rst:5921
msgid "Use :func:`sqlalchemy.text` to specify query parameters in a backend-neutral way"
msgstr ""

#: ../../source/user_guide/io.rst:5931
msgid "If you have an SQLAlchemy description of your database you can express where conditions using SQLAlchemy expressions"
msgstr ""

#: ../../source/user_guide/io.rst:5948
msgid "You can combine SQLAlchemy expressions with parameters passed to :func:`read_sql` using :func:`sqlalchemy.bindparam`"
msgstr ""

#: ../../source/user_guide/io.rst:5959
msgid "Sqlite fallback"
msgstr ""

#: ../../source/user_guide/io.rst:5961
msgid "The use of sqlite is supported without using SQLAlchemy. This mode requires a Python database adapter which respect the `Python DB-API <https://www.python.org/dev/peps/pep-0249/>`__."
msgstr ""

#: ../../source/user_guide/io.rst:5965
msgid "You can create connections like so:"
msgstr ""

#: ../../source/user_guide/io.rst:5973
msgid "And then issue the following queries:"
msgstr ""

#: ../../source/user_guide/io.rst:5984
msgid "Google BigQuery"
msgstr ""

#: ../../source/user_guide/io.rst:5986
msgid "The ``pandas-gbq`` package provides functionality to read/write from Google BigQuery."
msgstr ""

#: ../../source/user_guide/io.rst:5988
msgid "pandas integrates with this external package. if ``pandas-gbq`` is installed, you can use the pandas methods ``pd.read_gbq`` and ``DataFrame.to_gbq``, which will call the respective functions from ``pandas-gbq``."
msgstr ""

#: ../../source/user_guide/io.rst:5992
msgid "Full documentation can be found `here <https://pandas-gbq.readthedocs.io/en/latest/>`__."
msgstr ""

#: ../../source/user_guide/io.rst:5997
msgid "Stata format"
msgstr ""

#: ../../source/user_guide/io.rst:6002
msgid "Writing to stata format"
msgstr ""

#: ../../source/user_guide/io.rst:6004
msgid "The method :func:`~pandas.core.frame.DataFrame.to_stata` will write a DataFrame into a .dta file. The format version of this file is always 115 (Stata 12)."
msgstr ""

#: ../../source/user_guide/io.rst:6012
msgid "*Stata* data files have limited data type support; only strings with 244 or fewer characters, ``int8``, ``int16``, ``int32``, ``float32`` and ``float64`` can be stored in ``.dta`` files.  Additionally, *Stata* reserves certain values to represent missing data. Exporting a non-missing value that is outside of the permitted range in Stata for a particular data type will retype the variable to the next larger size.  For example, ``int8`` values are restricted to lie between -127 and 100 in Stata, and so variables with values above 100 will trigger a conversion to ``int16``. ``nan`` values in floating points data types are stored as the basic missing data type (``.`` in *Stata*)."
msgstr ""

#: ../../source/user_guide/io.rst:6025
msgid "It is not possible to export missing data values for integer data types."
msgstr ""

#: ../../source/user_guide/io.rst:6028
msgid "The *Stata* writer gracefully handles other data types including ``int64``, ``bool``, ``uint8``, ``uint16``, ``uint32`` by casting to the smallest supported type that can represent the data.  For example, data with a type of ``uint8`` will be cast to ``int8`` if all values are less than 100 (the upper bound for non-missing ``int8`` data in *Stata*), or, if values are outside of this range, the variable is cast to ``int16``."
msgstr ""

#: ../../source/user_guide/io.rst:6038
msgid "Conversion from ``int64`` to ``float64`` may result in a loss of precision if ``int64`` values are larger than 2**53."
msgstr ""

#: ../../source/user_guide/io.rst:6043
msgid ":class:`~pandas.io.stata.StataWriter` and :func:`~pandas.core.frame.DataFrame.to_stata` only support fixed width strings containing up to 244 characters, a limitation imposed by the version 115 dta file format. Attempting to write *Stata* dta files with strings longer than 244 characters raises a ``ValueError``."
msgstr ""

#: ../../source/user_guide/io.rst:6052
msgid "Reading from Stata format"
msgstr ""

#: ../../source/user_guide/io.rst:6054
msgid "The top-level function ``read_stata`` will read a dta file and return either a ``DataFrame`` or a :class:`pandas.api.typing.StataReader` that can be used to read the file incrementally."
msgstr ""

#: ../../source/user_guide/io.rst:6062
msgid "Specifying a ``chunksize`` yields a :class:`pandas.api.typing.StataReader` instance that can be used to read ``chunksize`` lines from the file at a time.  The ``StataReader`` object can be used as an iterator."
msgstr ""

#: ../../source/user_guide/io.rst:6073
msgid "For more fine-grained control, use ``iterator=True`` and specify ``chunksize`` with each call to :func:`~pandas.io.stata.StataReader.read`."
msgstr ""

#: ../../source/user_guide/io.rst:6083
msgid "Currently the ``index`` is retrieved as a column."
msgstr ""

#: ../../source/user_guide/io.rst:6085
msgid "The parameter ``convert_categoricals`` indicates whether value labels should be read and used to create a ``Categorical`` variable from them. Value labels can also be retrieved by the function ``value_labels``, which requires :func:`~pandas.io.stata.StataReader.read` to be called before use."
msgstr ""

#: ../../source/user_guide/io.rst:6090
msgid "The parameter ``convert_missing`` indicates whether missing value representations in Stata should be preserved.  If ``False`` (the default), missing values are represented as ``np.nan``.  If ``True``, missing values are represented using ``StataMissingValue`` objects, and columns containing missing values will have ``object`` data type."
msgstr ""

#: ../../source/user_guide/io.rst:6098
msgid ":func:`~pandas.read_stata` and :class:`~pandas.io.stata.StataReader` support .dta formats 113-115 (Stata 10-12), 117 (Stata 13), and 118 (Stata 14)."
msgstr ""

#: ../../source/user_guide/io.rst:6104
msgid "Setting ``preserve_dtypes=False`` will upcast to the standard pandas data types: ``int64`` for all integer types and ``float64`` for floating point data.  By default, the Stata data types are preserved when importing."
msgstr ""

#: ../../source/user_guide/io.rst:6110
msgid "All :class:`~pandas.io.stata.StataReader` objects, whether created by :func:`~pandas.read_stata` (when using ``iterator=True`` or ``chunksize``) or instantiated by hand, must be used as context managers (e.g. the ``with`` statement). While the :meth:`~pandas.io.stata.StataReader.close` method is available, its use is unsupported. It is not part of the public API and will be removed in with future without warning."
msgstr ""

#: ../../source/user_guide/io.rst:6126
msgid "``Categorical`` data can be exported to *Stata* data files as value labeled data. The exported data consists of the underlying category codes as integer data values and the categories as value labels.  *Stata* does not have an explicit equivalent to a ``Categorical`` and information about *whether* the variable is ordered is lost when exporting."
msgstr ""

#: ../../source/user_guide/io.rst:6134
msgid "*Stata* only supports string value labels, and so ``str`` is called on the categories when exporting data.  Exporting ``Categorical`` variables with non-string categories produces a warning, and can result a loss of information if the ``str`` representations of the categories are not unique."
msgstr ""

#: ../../source/user_guide/io.rst:6139
msgid "Labeled data can similarly be imported from *Stata* data files as ``Categorical`` variables using the keyword argument ``convert_categoricals`` (``True`` by default). The keyword argument ``order_categoricals`` (``True`` by default) determines whether imported ``Categorical`` variables are ordered."
msgstr ""

#: ../../source/user_guide/io.rst:6146
msgid "When importing categorical data, the values of the variables in the *Stata* data file are not preserved since ``Categorical`` variables always use integer data types between ``-1`` and ``n-1`` where ``n`` is the number of categories. If the original values in the *Stata* data file are required, these can be imported by setting ``convert_categoricals=False``, which will import original data (but not the variable labels). The original values can be matched to the imported categorical data since there is a simple mapping between the original *Stata* data values and the category codes of imported Categorical variables: missing values are assigned code ``-1``, and the smallest original value is assigned ``0``, the second smallest is assigned ``1`` and so on until the largest original value is assigned the code ``n-1``."
msgstr ""

#: ../../source/user_guide/io.rst:6160
msgid "*Stata* supports partially labeled series. These series have value labels for some but not all data values. Importing a partially labeled series will produce a ``Categorical`` with string categories for the values that are labeled and numeric categories for values with no label."
msgstr ""

#: ../../source/user_guide/io.rst:6170
msgid "SAS formats"
msgstr ""

#: ../../source/user_guide/io.rst:6172
msgid "The top-level function :func:`read_sas` can read (but not write) SAS XPORT (.xpt) and SAS7BDAT (.sas7bdat) format files."
msgstr ""

#: ../../source/user_guide/io.rst:6175
msgid "SAS files only contain two value types: ASCII text and floating point values (usually 8 bytes but sometimes truncated).  For xport files, there is no automatic type conversion to integers, dates, or categoricals.  For SAS7BDAT files, the format codes may allow date variables to be automatically converted to dates.  By default the whole file is read and returned as a ``DataFrame``."
msgstr ""

#: ../../source/user_guide/io.rst:6182
msgid "Specify a ``chunksize`` or use ``iterator=True`` to obtain reader objects (``XportReader`` or ``SAS7BDATReader``) for incrementally reading the file.  The reader objects also have attributes that contain additional information about the file and its variables."
msgstr ""

#: ../../source/user_guide/io.rst:6187
msgid "Read a SAS7BDAT file:"
msgstr ""

#: ../../source/user_guide/io.rst:6193
msgid "Obtain an iterator and read an XPORT file 100,000 lines at a time:"
msgstr ""

#: ../../source/user_guide/io.rst:6205
msgid "The specification_ for the xport file format is available from the SAS web site."
msgstr ""

#: ../../source/user_guide/io.rst:6210
msgid "No official documentation is available for the SAS7BDAT format."
msgstr ""

#: ../../source/user_guide/io.rst:6217
msgid "SPSS formats"
msgstr ""

#: ../../source/user_guide/io.rst:6219
msgid "The top-level function :func:`read_spss` can read (but not write) SPSS SAV (.sav) and  ZSAV (.zsav) format files."
msgstr ""

#: ../../source/user_guide/io.rst:6222
msgid "SPSS files contain column names. By default the whole file is read, categorical columns are converted into ``pd.Categorical``, and a ``DataFrame`` with all columns is returned."
msgstr ""

#: ../../source/user_guide/io.rst:6226
msgid "Specify the ``usecols`` parameter to obtain a subset of columns. Specify ``convert_categoricals=False`` to avoid converting categorical columns into ``pd.Categorical``."
msgstr ""

#: ../../source/user_guide/io.rst:6229
msgid "Read an SPSS file:"
msgstr ""

#: ../../source/user_guide/io.rst:6235
msgid "Extract a subset of columns contained in ``usecols`` from an SPSS file and avoid converting categorical columns into ``pd.Categorical``:"
msgstr ""

#: ../../source/user_guide/io.rst:6246
msgid "More information about the SAV and ZSAV file formats is available here_."
msgstr ""

#: ../../source/user_guide/io.rst:6253
msgid "Other file formats"
msgstr ""

#: ../../source/user_guide/io.rst:6255
msgid "pandas itself only supports IO with a limited set of file formats that map cleanly to its tabular data model. For reading and writing other file formats into and from pandas, we recommend these packages from the broader community."
msgstr ""

#: ../../source/user_guide/io.rst:6260
msgid "netCDF"
msgstr ""

#: ../../source/user_guide/io.rst:6262
msgid "xarray_ provides data structures inspired by the pandas ``DataFrame`` for working with multi-dimensional datasets, with a focus on the netCDF file format and easy conversion to and from pandas."
msgstr ""

#: ../../source/user_guide/io.rst:6271
msgid "Performance considerations"
msgstr ""

#: ../../source/user_guide/io.rst:6273
msgid "This is an informal comparison of various IO methods, using pandas 0.24.2. Timings are machine dependent and small differences should be ignored."
msgstr ""

#: ../../source/user_guide/io.rst:6291
msgid "The following test functions will be used below to compare the performance of several IO methods:"
msgstr ""

#: ../../source/user_guide/io.rst:6396
msgid "When writing, the top three functions in terms of speed are ``test_feather_write``, ``test_hdf_fixed_write`` and ``test_hdf_fixed_write_compress``."
msgstr ""

#: ../../source/user_guide/io.rst:6430
msgid "When reading, the top three functions in terms of speed are ``test_feather_read``, ``test_pickle_read`` and ``test_hdf_fixed_read``."
msgstr ""

#: ../../source/user_guide/io.rst:6467
msgid "The files ``test.pkl.compress``, ``test.parquet`` and ``test.feather`` took the least space on disk (in bytes)."
msgstr ""
